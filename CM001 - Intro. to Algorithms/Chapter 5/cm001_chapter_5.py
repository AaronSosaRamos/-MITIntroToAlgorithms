# -*- coding: utf-8 -*-
"""CM001 - Chapter 5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bAkkSTzUcXsZ_-0j1NPJ8OIGdwRKP-Mg

# Binary Trees
"""

class TreeNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None
        self.size = 1
        self.height = 1

class BinaryTree:
    def __init__(self):
        self.root = None

    def subtree(self, node):
        """Returns the subtree rooted at a given node."""
        return node

    def depth(self, node):
        """Returns the depth of a given node."""
        if node is None:
            return 0
        depth = 0
        while node.parent:
            depth += 1
            node = node.parent
        return depth

    def height(self, node):
        """Returns the height of a given node."""
        if node is None:
            return 0
        return node.height

    def insert(self, key):
        """Inserts a node with a given key into the binary tree."""
        new_node = TreeNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self._insert_recursive(self.root, new_node)
        self._update_sizes_and_heights(new_node)

    def _insert_recursive(self, root, node):
        """Helper method for inserting a node recursively."""
        if node.key < root.key:
            if root.left is None:
                root.left = node
                node.parent = root
            else:
                self._insert_recursive(root.left, node)
        else:
            if root.right is None:
                root.right = node
                node.parent = root
            else:
                self._insert_recursive(root.right, node)

    def _update_sizes_and_heights(self, node):
        """Update size and height attributes after insertion."""
        while node:
            node.size = 1 + self._get_size(node.left) + self._get_size(node.right)
            node.height = 1 + max(self.height(node.left), self.height(node.right))
            node = node.parent

    def _get_size(self, node):
        """Returns the size of the subtree rooted at a given node."""
        return node.size if node else 0

    def delete(self, key):
        """Deletes a node with a given key from the binary tree."""
        node = self.search(key)
        if node:
            self._delete_node(node)

    def _delete_node(self, node):
        """Helper method to delete a node."""
        if node.left is None:
            self._transplant(node, node.right)
        elif node.right is None:
            self._transplant(node, node.left)
        else:
            successor = self.minimum(node.right)
            if successor.parent != node:
                self._transplant(successor, successor.right)
                successor.right = node.right
                successor.right.parent = successor
            self._transplant(node, successor)
            successor.left = node.left
            successor.left.parent = successor
        self._update_sizes_and_heights(node.parent)

    def _transplant(self, u, v):
        """Transplants subtree rooted at v to subtree rooted at u."""
        if u.parent is None:
            self.root = v
        elif u == u.parent.left:
            u.parent.left = v
        else:
            u.parent.right = v
        if v:
            v.parent = u.parent

    def minimum(self, node):
        """Finds the minimum key node in the subtree rooted at a given node."""
        while node.left:
            node = node.left
        return node

    def maximum(self, node):
        """Finds the maximum key node in the subtree rooted at a given node."""
        while node.right:
            node = node.right
        return node

    def first(self):
        """Returns the node with the smallest key in the binary tree."""
        return self.minimum(self.root)

    def last(self):
        """Returns the node with the largest key in the binary tree."""
        return self.maximum(self.root)

    def predecessor(self, node):
        """Returns the predecessor of a given node."""
        if node.left:
            return self.maximum(node.left)
        parent = node.parent
        while parent and node == parent.left:
            node = parent
            parent = parent.parent
        return parent

    def successor(self, node):
        """Returns the successor of a given node."""
        if node.right:
            return self.minimum(node.right)
        parent = node.parent
        while parent and node == parent.right:
            node = parent
            parent = parent.parent
        return parent

    def subtree_first(self, node):
        """Returns the node with the smallest key in the subtree rooted at a given node."""
        return self.minimum(node)

    def subtree_find(self, root, key):
        """Finds a node with a given key in the subtree rooted at a given node."""
        while root:
            if key == root.key:
                return root
            elif key < root.key:
                root = root.left
            else:
                root = root.right
        return None

    def size(self, node):
        """Returns the number of nodes in the subtree rooted at a given node."""
        return node.size if node else 0

    def subtree_at(self, node, index):
        """Returns the node at a given index in the subtree rooted at a given node."""
        if node is None:
            return None
        left_size = self.size(node.left)
        if index < left_size:
            return self.subtree_at(node.left, index)
        elif index == left_size:
            return node
        else:
            return self.subtree_at(node.right, index - left_size - 1)

    def subtree_augmentation(self, node):
        """Augments subtree rooted at a given node."""
        if node:
            node.size = 1 + self._get_size(node.left) + self._get_size(node.right)
            node.height = 1 + max(self.height(node.left), self.height(node.right))
            self.subtree_augmentation(node.left)
            self.subtree_augmentation(node.right)

    def sequence_binary_tree(self):
        """Returns a sequence binary tree via subtree sizes."""
        sequence_tree = BinaryTree()
        sequence_tree.root = self._sequence_binary_tree_helper(self.root)
        return sequence_tree

    def _sequence_binary_tree_helper(self, node):
        """Helper method for constructing sequence binary tree."""
        if node is None:
            return None
        new_node = TreeNode(node.size)
        new_node.left = self._sequence_binary_tree_helper(node.left)
        new_node.right = self._sequence_binary_tree_helper(node.right)
        return new_node

    def height_balance(self):
        """Balances the binary tree using AVL rotations."""
        self.subtree_augmentation(self.root)
        self._height_balance_helper(self.root)

    def _height_balance_helper(self, node):
        """Helper method for height balancing."""
        if node:
            balance_factor = self._balance_factor(node)
            if balance_factor > 1:
                if self._balance_factor(node.left) < 0:
                    self._left_rotate(node.left)
                self._right_rotate(node)
            elif balance_factor < -1:
                if self._balance_factor(node.right) > 0:
                    self._right_rotate(node.right)
                self._left_rotate(node)
            self._height_balance_helper(node.left)
            self._height_balance_helper(node.right)

    def _balance_factor(self, node):
        """Calculates the balance factor of a node."""
        return self.height(node.left) - self.height(node.right)

    def _left_rotate(self, x):
        """Performs left rotation."""
        y = x.right
        x.right = y.left
        if y.left:
            y.left.parent = x
        y.parent = x.parent
        if x.parent is None:
            self.root = y
        elif x == x.parent.left:
            x.parent.left = y
        else:
            x.parent.right = y
        y.left = x
        x.parent = y
        self.subtree_augmentation(x)

    def _right_rotate(self, y):
        """Performs right rotation."""
        x = y.left
        y.left = x.right
        if x.right:
            x.right.parent = y
        x.parent = y.parent
        if y.parent is None:
            self.root = x
        elif y == y.parent.right:
            y.parent.right = x
        else:
            y.parent.left = x
        x.right = y
        y.parent = x
        self.subtree_augmentation(y)

    def rotations(self):
        """Performs rotations in AVL tree."""
        self.height_balance()

    def rebalancing(self):
        """Rebalances the binary tree."""
        self.height_balance()

    def sorting(self):
        """Sorts the binary tree."""
        sorted_keys = []
        self._inorder_traversal_helper(self.root, sorted_keys)
        return sorted_keys

    def _inorder_traversal_helper(self, node, sorted_keys):
        """Helper method for inorder traversal."""
        if node:
            self._inorder_traversal_helper(node.left, sorted_keys)
            sorted_keys.append(node.key)
            self._inorder_traversal_helper(node.right, sorted_keys)

    def inorder_traversal(self, node):
        """Performs inorder traversal of the binary tree."""
        if node:
            self.inorder_traversal(node.left)
            print(node.key, end=" ")
            self.inorder_traversal(node.right)

    def preorder_traversal(self, node):
        """Performs preorder traversal of the binary tree."""
        if node:
            print(node.key, end=" ")
            self.preorder_traversal(node.left)
            self.preorder_traversal(node.right)

    def postorder_traversal(self, node):
        """Performs postorder traversal of the binary tree."""
        if node:
            self.postorder_traversal(node.left)
            self.postorder_traversal(node.right)
            print(node.key, end=" ")

# Create a binary tree
tree = BinaryTree()

# Insert nodes
tree.insert(50)
tree.insert(30)
tree.insert(70)
tree.insert(20)
tree.insert(40)
tree.insert(60)
tree.insert(80)

# Subtree
subtree_root = tree.root.right
subtree = tree.subtree(subtree_root)
print("Subtree rooted at", subtree_root.key, ":", end=" ")
tree.inorder_traversal(subtree)
print()

# Depth
depth = tree.depth(tree.root.right.right)
print("Depth of node with key 80:", depth)

# Height
height = tree.height(tree.root.right.right)
print("Height of node with key 80:", height)

# First
first_node = tree.first()
print("First node (smallest key):", first_node.key)

# Last
last_node = tree.last()
print("Last node (largest key):", last_node.key)

# Predecessor
predecessor_node = tree.predecessor(tree.root.right.right)
print("Predecessor of node with key 80:", predecessor_node.key)

# Successor
successor_node = tree.successor(tree.root.left)
print("Successor of node with key 30:", successor_node.key)

# Subtree first
subtree_first_node = tree.subtree_first(tree.root.right)
print("First node in subtree rooted at", tree.root.right.key, ":", subtree_first_node.key)

# Subtree find
key_to_find = 40
found_node = tree.subtree_find(tree.root, key_to_find)
if found_node:
    print("Node with key", key_to_find, "found in subtree rooted at", tree.root.key, ":", found_node.key)
else:
    print("Node with key", key_to_find, "not found")

# Size
size_of_subtree = tree.size(tree.root.right)
print("Size of subtree rooted at", tree.root.right.key, ":", size_of_subtree)

# Subtree at
index = 2
node_at_index = tree.subtree_at(tree.root, index)
print("Node at index", index, ":", node_at_index.key)

# Subtree augmentation
tree.subtree_augmentation(tree.root)
print("Size of subtree rooted at", tree.root.key, "after augmentation:", tree.root.size)
print("Height of subtree rooted at", tree.root.key, "after augmentation:", tree.root.height)

# Sequence binary tree
sequence_tree = tree.sequence_binary_tree()
print("Sequence binary tree:")
tree.inorder_traversal(sequence_tree.root)
print()

# Height balance
tree.height_balance()
print("Height balanced tree:")
tree.inorder_traversal(tree.root)
print()

# Rotations (no visible change in this example)
tree.rotations()

# Rebalancing (no visible change in this example)
tree.rebalancing()

# Sorting
sorted_keys = tree.sorting()
print("Sorted keys:", sorted_keys)

# Inorder Traversal
print("Inorder Traversal:")
tree.inorder_traversal(tree.root)
print()

# Preorder Traversal
print("Preorder Traversal:")
tree.preorder_traversal(tree.root)
print()

# Postorder Traversal
print("Postorder Traversal:")
tree.postorder_traversal(tree.root)
print()
# -*- coding: utf-8 -*-
"""CM001 - Chapter 7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q08qLXxAwlG_UFMTXK6S-lseRC99KmGh

#Graphs Algorithms

G = (V,E)
V = Vertices
E = Edges

Simple Graph:


* No self loops
* Every edge is distinct

|E| = O(|V|^2)
"""

class DirectedSimpleGraph:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_matrix = [[0] * num_vertices for _ in range(num_vertices)]

    def add_edge(self, src, dest):
        if src == dest:
            print("Self-loops are not allowed.")
            return
        if self.adj_matrix[src][dest] == 1:
            print("Edge already exists.")
            return
        self.adj_matrix[src][dest] = 1

    def outgoing_neighbors(self, vertex):
        neighbors = []
        for dest, value in enumerate(self.adj_matrix[vertex]):
            if value == 1:
                neighbors.append(dest)
        return neighbors

    def incoming_neighbors(self, vertex):
        neighbors = []
        for src in range(self.num_vertices):
            if self.adj_matrix[src][vertex] == 1:
                neighbors.append(src)
        return neighbors

    def out_degree(self, vertex):
        return sum(self.adj_matrix[vertex])

    def in_degree(self, vertex):
        return sum(row[vertex] for row in self.adj_matrix)

    def display(self):
        for row in self.adj_matrix:
            print(" ".join(map(str, row)))


class UndirectedSimpleGraph:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_matrix = [[0] * num_vertices for _ in range(num_vertices)]

    def add_edge(self, src, dest):
        if src == dest:
            print("Self-loops are not allowed.")
            return
        if self.adj_matrix[src][dest] == 1 or self.adj_matrix[dest][src] == 1:
            print("Edge already exists.")
            return
        self.adj_matrix[src][dest] = 1
        self.adj_matrix[dest][src] = 1

    def outgoing_neighbors(self, vertex):
        neighbors = []
        for dest, value in enumerate(self.adj_matrix[vertex]):
            if value == 1:
                neighbors.append(dest)
        return neighbors

    def incoming_neighbors(self, vertex):
        return self.outgoing_neighbors(vertex)

    def degree(self, vertex):
        return sum(self.adj_matrix[vertex])

    def display(self):
        for row in self.adj_matrix:
            print(" ".join(map(str, row)))


num_vertices = 5
directed_graph = DirectedSimpleGraph(num_vertices)
directed_graph.add_edge(0, 1)
directed_graph.add_edge(0, 2)
directed_graph.add_edge(1, 3)
directed_graph.add_edge(2, 4)

print("Directed Graph:")
directed_graph.display()
print("Outgoing neighbors of vertex 0:", directed_graph.outgoing_neighbors(0))
print("Incoming neighbors of vertex 3:", directed_graph.incoming_neighbors(3))
print("Out-degree of vertex 0:", directed_graph.out_degree(0))
print("In-degree of vertex 3:", directed_graph.in_degree(3))

undirected_graph = UndirectedSimpleGraph(num_vertices)
undirected_graph.add_edge(0, 1)
undirected_graph.add_edge(0, 2)
undirected_graph.add_edge(1, 3)
undirected_graph.add_edge(2, 4)

print("\nUndirected Graph:")
undirected_graph.display()
print("Outgoing neighbors of vertex 0:", undirected_graph.outgoing_neighbors(0))
print("Incoming neighbors of vertex 3:", undirected_graph.incoming_neighbors(3))
print("Degree of vertex 0:", undirected_graph.degree(0))
print("Degree of vertex 3:", undirected_graph.degree(3))

"""# Graph Representations

#Edge List
"""

class SimpleGraph:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_matrix = [[0] * num_vertices for _ in range(num_vertices)]

    def add_edge(self, src, dest):
        if src == dest:
            print("Self-loops are not allowed.")
            return
        if self.adj_matrix[src][dest] == 1:
            print("Edge already exists.")
            return
        self.adj_matrix[src][dest] = 1

    def edge_list(self):
        edges = []
        for src in range(self.num_vertices):
            for dest in range(self.num_vertices):
                if self.adj_matrix[src][dest] == 1:
                    edges.append((src, dest))
        return edges


num_vertices = 5
graph = SimpleGraph(num_vertices)
graph.add_edge(0, 1)
graph.add_edge(0, 2)
graph.add_edge(1, 3)
graph.add_edge(2, 4)

print("Edge List:")
print(graph.edge_list())

"""# Adjacency List"""

class SimpleGraph:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_list = [[] for _ in range(num_vertices)]

    def add_edge(self, src, dest):
        if src == dest:
            print("Self-loops are not allowed.")
            return
        if dest not in self.adj_list[src]:
            self.adj_list[src].append(dest)
        if src not in self.adj_list[dest]:
            self.adj_list[dest].append(src)

    def adjacency_list(self):
        return self.adj_list


num_vertices = 5
graph = SimpleGraph(num_vertices)
graph.add_edge(0, 1)
graph.add_edge(0, 2)
graph.add_edge(1, 3)
graph.add_edge(2, 4)

print("Adjacency List:")
print(graph.adjacency_list())

"""# Adjacency Matrix"""

class SimpleGraph:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_matrix = [[0] * num_vertices for _ in range(num_vertices)]

    def add_edge(self, src, dest):
        if src == dest:
            print("Self-loops are not allowed.")
            return
        self.adj_matrix[src][dest] = 1
        self.adj_matrix[dest][src] = 1

    def adjacency_matrix(self):
        return self.adj_matrix


num_vertices = 5
graph = SimpleGraph(num_vertices)
graph.add_edge(0, 1)
graph.add_edge(0, 2)
graph.add_edge(1, 3)
graph.add_edge(2, 4)

print("Adjacency Matrix:")
for row in graph.adjacency_matrix():
    print(row)

"""#Model Graph Problems

Single Pair Reachability and Single Pair Shortest Path
"""

from collections import deque
import heapq

class SimpleGraph:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_list = [[] for _ in range(num_vertices)]

    def add_edge(self, src, dest):
        if dest not in self.adj_list[src]:
            self.adj_list[src].append(dest)
        if src not in self.adj_list[dest]:
            self.adj_list[dest].append(src)

    def is_reachable(self, src, dest):
        visited = [False] * self.num_vertices
        queue = deque([src])
        visited[src] = True

        while queue:
            current = queue.popleft()
            if current == dest:
                return True
            for neighbor in self.adj_list[current]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)
        return False

    def bfs_shortest_path(self, src, dest):
        visited = [False] * self.num_vertices
        distance = [-1] * self.num_vertices
        queue = deque([src])
        visited[src] = True
        distance[src] = 0

        while queue:
            current = queue.popleft()
            if current == dest:
                return distance[current]
            for neighbor in self.adj_list[current]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    distance[neighbor] = distance[current] + 1
                    queue.append(neighbor)
        return -1

num_vertices = 5
graph = SimpleGraph(num_vertices)
graph.add_edge(0, 1)
graph.add_edge(0, 2)
graph.add_edge(1, 3)
graph.add_edge(2, 4)

src = 0
dest = 3
print("Is {} reachable from {}?".format(dest, src), graph.is_reachable(src, dest))
print("Shortest path length from {} to {}: ".format(src, dest), graph.bfs_shortest_path(src, dest))

"""Single Pair Reachability and Single Pair Shortest Path, Single Source Shortest Paths (Djikstra Algo.) (Considering weight)"""

from collections import deque
import heapq

class SimpleGraph:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_list = [[] for _ in range(num_vertices)]

    def add_edge(self, src, dest, weight):
        if dest not in self.adj_list[src]:
            self.adj_list[src].append((dest, weight))
        if src not in self.adj_list[dest]:
            self.adj_list[dest].append((src, weight))

    def is_reachable(self, src, dest):
        visited = [False] * self.num_vertices
        queue = deque([src])
        visited[src] = True

        while queue:
            current = queue.popleft()
            if current == dest:
                return True
            for neighbor, _ in self.adj_list[current]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)
        return False

    def bfs_shortest_path(self, src, dest): #Breadth-First Search Example
        visited = [False] * self.num_vertices
        distance = [-1] * self.num_vertices
        queue = deque([src])
        visited[src] = True
        distance[src] = 0

        while queue:
            current = queue.popleft()
            if current == dest:
                return distance[current]
            for neighbor, _ in self.adj_list[current]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    distance[neighbor] = distance[current] + 1
                    queue.append(neighbor)
        return -1

    def dijkstra_shortest_paths(self, source):
        distances = [float('inf')] * self.num_vertices
        distances[source] = 0
        visited = [False] * self.num_vertices

        priority_queue = [(0, source)]
        while priority_queue:
            dist_to_current, current_vertex = heapq.heappop(priority_queue)
            if visited[current_vertex]:
                continue
            visited[current_vertex] = True
            for neighbor, edge_weight in self.adj_list[current_vertex]:
                if not visited[neighbor]:
                    new_distance = dist_to_current + edge_weight
                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
                        heapq.heappush(priority_queue, (new_distance, neighbor))

        return distances

num_vertices = 5
graph = SimpleGraph(num_vertices)
graph.add_edge(0, 1, 4)
graph.add_edge(0, 2, 1)
graph.add_edge(1, 3, 1)
graph.add_edge(2, 4, 2)

source_vertex = 0
print("Is {} reachable from {}?".format(dest, src), graph.is_reachable(src, dest))
print("Shortest path length from {} to {}: ".format(src, dest), graph.bfs_shortest_path(src, dest))
shortest_paths = graph.dijkstra_shortest_paths(source_vertex)
print("Single Source Shortest Paths from vertex", source_vertex)
for i, distance in enumerate(shortest_paths):
    print("Distance to vertex", i, ":", distance)

"""#Breadth-First Search"""

from collections import deque

class SimpleGraph:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_list = [[] for _ in range(num_vertices)]

    def add_edge(self, src, dest, weight=None):
        if dest not in self.adj_list[src]:
            self.adj_list[src].append(dest)
        if src not in self.adj_list[dest]:
            self.adj_list[dest].append(src)

    def bfs(self, start_vertex):
        visited = [False] * self.num_vertices
        queue = deque([start_vertex])
        visited[start_vertex] = True

        while queue:
            current = queue.popleft()
            print(current, end=" ")
            for neighbor in self.adj_list[current]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)

num_vertices = 5
graph = SimpleGraph(num_vertices)
graph.add_edge(0, 1)
graph.add_edge(0, 2)
graph.add_edge(1, 3)
graph.add_edge(2, 4)

print("Breadth-First Search:")
graph.bfs(0)
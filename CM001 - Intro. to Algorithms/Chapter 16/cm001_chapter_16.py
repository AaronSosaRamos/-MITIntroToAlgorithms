# -*- coding: utf-8 -*-
"""CM001 - Chapter 16.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wcGb2KrzgQWa4YgLYF2ysyNnmJumUzHP

#LCS with DAG
"""

def longest_common_subsequence(X, Y):
    m, n = len(X), len(Y)
    # Construct DAG
    graph = {(i, j): [] for i in range(m+1) for j in range(n+1)}
    for i in range(m):
        for j in range(n):
            if X[i] == Y[j]:
                graph[(i, j)].append((i+1, j+1))
    # Topological sort
    def topological_sort(graph):
        visited = set()
        order = []
        def dfs(node):
            if node not in visited:
                visited.add(node)
                for neighbor in graph[node]:
                    dfs(neighbor)
                order.append(node)
        for node in graph:
            dfs(node)
        return order[::-1]
    top_order = topological_sort(graph)
    # Calculate LCS length
    lcs_lengths = {(i, j): 0 for i in range(m+1) for j in range(n+1)}
    for node in top_order:
        i, j = node
        if i == m or j == n:
            lcs_lengths[node] = 0
        elif X[i] == Y[j]:
            lcs_lengths[node] = 1 + lcs_lengths[(i+1, j+1)]
        else:
            lcs_lengths[node] = max(lcs_lengths[(i+1, j)], lcs_lengths[(i, j+1)])
    # Reconstruct LCS
    lcs = []
    i, j = 0, 0
    while i < m and j < n:
        if X[i] == Y[j]:
            lcs.append(X[i])
            i += 1
            j += 1
        elif lcs_lengths[(i+1, j)] >= lcs_lengths[(i, j+1)]:
            i += 1
        else:
            j += 1
    return ''.join(lcs)

# Example usage:
X = "ABCBDAB"
Y = "BDCAB"
print("Longest Common Subsequence:", longest_common_subsequence(X, Y))  # Output: "BCAB"

"""#LIS with DAG"""

from collections import defaultdict

def longest_increasing_subsequence(nums):
    # Construct the DAG
    graph = defaultdict(list)
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if nums[j] > nums[i]:
                graph[i].append(j)

    # Perform topological sort
    def topological_sort(graph):
        visited = set()
        stack = []

        def dfs(node):
            visited.add(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    dfs(neighbor)
            stack.append(node)

        for node in list(graph.keys()):  # Iterate over a copy of the keys
            if node not in visited:
                dfs(node)

        return stack[::-1]

    top_order = topological_sort(graph)

    # Dynamic Programming to find the longest increasing subsequence
    dp = [1] * len(nums)
    for node in top_order:
        for neighbor in graph[node]:
            dp[neighbor] = max(dp[neighbor], dp[node] + 1)

    # Find the maximum value in dp array
    max_length = max(dp)
    return max_length

# Example usage:
nums = [10, 22, 9, 33, 21, 50, 41, 60, 80]
print("Length of Longest Increasing Subsequence:", longest_increasing_subsequence(nums))

"""#Alternating Coin Game with DAG"""

class DAG:
    def __init__(self, num_nodes):
        self.num_nodes = num_nodes
        self.adj_list = [[] for _ in range(num_nodes)]
        self.in_degree = [0] * num_nodes

    def add_edge(self, u, v):
        self.adj_list[u].append(v)
        self.in_degree[v] += 1

    def topological_sort(self):
        stack = []
        visited = [False] * self.num_nodes

        for node in range(self.num_nodes):
            if self.in_degree[node] == 0:
                stack.append(node)

        topo_order = []

        while stack:
            u = stack.pop()
            topo_order.append(u)

            for v in self.adj_list[u]:
                self.in_degree[v] -= 1
                if self.in_degree[v] == 0:
                    stack.append(v)

        return topo_order

def alternating_coin_problem(n, coins):
    dag = DAG(n)

    for i in range(n):
        for j in range(i + 1, n):
            if coins[i] != coins[j]:
                dag.add_edge(i, j)

    topo_order = dag.topological_sort()

    dp = [0] * n

    for node in topo_order:
        for next_node in dag.adj_list[node]:
            dp[next_node] = max(dp[next_node], dp[node] + 1)

    return max(dp) + 1

# Example usage:
n = 5
coins = [1, 0, 1, 0, 1]  # Sample coins list
result = alternating_coin_problem(n, coins)
print("Maximum alternating subsequence length:", result)
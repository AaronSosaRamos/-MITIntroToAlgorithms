# -*- coding: utf-8 -*-
"""CM001 - Chapter 8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17-79tEnsFNSIxSlbvHQ8Kjl0Qy2wKqMQ

# AVL Sort
"""

class AVLNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1


class AVLTree:
    def __init__(self):
        self.root = None

    def height(self, node):
        if node is None:
            return 0
        return node.height

    def balance(self, node):
        if node is None:
            return 0
        return self.height(node.left) - self.height(node.right)

    def rotate_right(self, y):
        x = y.left
        T2 = x.right

        x.right = y
        y.left = T2

        y.height = 1 + max(self.height(y.left), self.height(y.right))
        x.height = 1 + max(self.height(x.left), self.height(x.right))

        return x

    def rotate_left(self, x):
        y = x.right
        T2 = y.left

        y.left = x
        x.right = T2

        x.height = 1 + max(self.height(x.left), self.height(x.right))
        y.height = 1 + max(self.height(y.left), self.height(y.right))

        return y

    def insert(self, root, key):
        if not root:
            return AVLNode(key)
        elif key < root.key:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)

        root.height = 1 + max(self.height(root.left), self.height(root.right))

        balance = self.balance(root)

        if balance > 1:
            if key < root.left.key:
                return self.rotate_right(root)
            else:
                root.left = self.rotate_left(root.left)
                return self.rotate_right(root)

        if balance < -1:
            if key > root.right.key:
                return self.rotate_left(root)
            else:
                root.right = self.rotate_right(root.right)
                return self.rotate_left(root)

        return root

    def sort(self, root):
        if root:
            self.sort(root.left)
            print(root.key, end=' ')
            self.sort(root.right)

    def avl_sort(self, arr):
        for key in arr:
            self.root = self.insert(self.root, key)
        self.sort(self.root)


if __name__ == "__main__":
    tree = AVLTree()
    arr = [5, 3, 6, 2, 4, 1]
    print("Original array:", arr)
    print("Sorted array:", end=' ')
    tree.avl_sort(arr)

"""# Depth-First Search"""

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.adj_list = [[] for _ in range(vertices)]

    def add_edge(self, u, v):
        self.adj_list[u].append(v)

    def dfs_search_util(self, v, target, visited):
        if v == target:
            return True

        visited[v] = True

        for i in self.adj_list[v]:
            if not visited[i]:
                if self.dfs_search_util(i, target, visited):
                    return True
        return False

    def dfs_search(self, start, target):
        visited = [False] * self.V
        return self.dfs_search_util(start, target, visited)


if __name__ == "__main__":
    graph = Graph(4)
    graph.add_edge(0, 1)
    graph.add_edge(0, 2)
    graph.add_edge(1, 2)
    graph.add_edge(2, 0)
    graph.add_edge(2, 3)
    graph.add_edge(3, 3)

    start_node = 2
    target_node = 3

    print("Depth-First Search:")
    if graph.dfs_search(start_node, target_node):
        print(f"Target node {target_node} is reachable from start node {start_node}.")
    else:
        print(f"Target node {target_node} is not reachable from start node {start_node}.")

"""Depth-First Search (DFS):
- Starts at a chosen node and explores as far as possible along each branch before backtracking.
- Uses a stack or recursion to keep track of nodes to visit.
- It is not guaranteed to find the shortest path.

Breadth-First Search (BFS):
- Starts at a chosen node and explores all of the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.
- Uses a queue to keep track of nodes to visit.
- Guarantees finding the shortest path in an unweighted graph.

# Directed Acyclic Graph (DAG) and Topological Order
"""

class DAG:
    def __init__(self):
        self.graph = {}

    def add_node(self, node):
        if node not in self.graph:
            self.graph[node] = []

    def add_edge(self, source, destination):
        if source in self.graph and destination in self.graph:
            self.graph[source].append(destination)
        else:
            raise ValueError("Source or destination node not found in graph")

    def topological_sort_util(self, node, visited, stack):
        visited[node] = True
        for neighbor in self.graph[node]:
            if not visited[neighbor]:
                self.topological_sort_util(neighbor, visited, stack)
        stack.append(node)

    def topological_sort(self):
        visited = {node: False for node in self.graph}
        stack = []
        for node in self.graph:
            if not visited[node]:
                self.topological_sort_util(node, visited, stack)
        return stack[::-1]


if __name__ == "__main__":
    dag = DAG()
    dag.add_node('A')
    dag.add_node('B')
    dag.add_node('C')
    dag.add_node('D')
    dag.add_node('E')
    dag.add_edge('A', 'B')
    dag.add_edge('A', 'C')
    dag.add_edge('B', 'D')
    dag.add_edge('C', 'D')
    dag.add_edge('D', 'E')

    print("Topological order:", dag.topological_sort())
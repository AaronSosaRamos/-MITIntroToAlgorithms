# -*- coding: utf-8 -*-
"""CM001 - Chapter 15.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KC4iK6crMM2Fffu0PcscS2A19GiezXXh

#Dynamic Programming

#SRTBOT
*   Subproblem definition
*   Relate subproblem solutions recursively
*   Topological order ob subprobs to guarantee cyclic => Subproblem / Call DAG
*   Base cases of relation
*   Original problem: Solve via subproblems
*   Time analysis

Merge Sort Example:
"""

import time
import matplotlib.pyplot as plt
import numpy as np

# 1. Subproblem definition: Divide the array into two halves
def merge_sort(arr):
    # 4. Base cases of relation: If the array has 0 or 1 elements, it is already sorted
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]

    # 2. Relate subproblem solutions recursively: Sort the two halves separately
    left_half_sorted = merge_sort(left_half)
    right_half_sorted = merge_sort(right_half)

    # 5. Original problem: Solve via subproblems
    return merge(left_half_sorted, right_half_sorted)

# Merge the sorted halves
def merge(left, right):
    result = []
    left_index = right_index = 0

    # 3. Topological order of subproblems to guarantee cyclic => Subproblem / Call DAG
    while left_index < len(left) and right_index < len(right):
        if left[left_index] < right[right_index]:
            result.append(left[left_index])
            left_index += 1
        else:
            result.append(right[right_index])
            right_index += 1

    result.extend(left[left_index:])
    result.extend(right[right_index:])

    # 6. Time analysis: The time complexity analysis of Merge Sort, which is O(n log n), is inherent in the algorithm's design.
    return result

# Function to test Merge Sort with arrays of different sizes and measure time taken
def test_merge_sort(array_sizes):
    times = []
    for size in array_sizes:
        arr = np.random.randint(0, 1000, size=size)
        start_time = time.time()
        merge_sort(arr)
        end_time = time.time()
        times.append(end_time - start_time)
    return times

# Array sizes for testing
array_sizes = [10, 100, 500, 1000, 2000, 5000]

# Measure time taken for sorting arrays of different sizes
times = test_merge_sort(array_sizes)

# Plot the results
plt.plot(array_sizes, times, marker='o')
plt.title('Merge Sort Time Complexity')
plt.xlabel('Array Size')
plt.ylabel('Time (seconds)')
plt.grid(True)
plt.show()

"""#Fibonacci Numbers"""

import time
import matplotlib.pyplot as plt

# 1. Subproblem definition: Define the subproblems as finding the (n-1)th and (n-2)th Fibonacci numbers
def fibonacci(n):
    # 4. Base cases of relation: Define base cases for Fibonacci numbers
    if n <= 1:
        return n

    fib_minus_1 = fibonacci(n - 1)
    fib_minus_2 = fibonacci(n - 2)

    # 2. Relate subproblem solutions recursively: Calculate the nth Fibonacci number by adding the solutions of subproblems
    fib_n = fib_minus_1 + fib_minus_2

    return fib_n

# Function to test Fibonacci number generation with different indices and measure time taken
def test_fibonacci(indices):
    times = []
    for n in indices:
        start_time = time.time()
        fibonacci(n)
        end_time = time.time()
        times.append(end_time - start_time)
    return times

# Test Fibonacci function for indices ranging from 1 to 30
indices = list(range(1, 30))

# Measure time taken for Fibonacci number generation
times = test_fibonacci(indices)

# Plot the results
plt.plot(indices, times, marker='o')
plt.title('Fibonacci Time Complexity')
plt.xlabel('Index of Fibonacci Number')
plt.ylabel('Time (seconds)')
plt.grid(True)
plt.show()

"""#Prefixes, suffixes and substrings"""

def prefix_sum(arr):
    n = len(arr)
    prefix = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix[i] = prefix[i - 1] + arr[i - 1]
    return prefix

# Example usage:
arr1 = [1, 2, 3, 4, 5]
prefix1 = prefix_sum(arr1)
print("Prefix sum for", arr1, ":", prefix1)

arr2 = [10, 20, 30, 40, 50]
prefix2 = prefix_sum(arr2)
print("Prefix sum for", arr2, ":", prefix2)

def suffix_sum(arr):
    n = len(arr)
    suffix = [0] * (n + 1)
    for i in range(n - 1, -1, -1):
        suffix[i] = suffix[i + 1] + arr[i]
    return suffix

# Example usage:
arr1 = [1, 2, 3, 4, 5]
suffix1 = suffix_sum(arr1)
print("Suffix sum for", arr1, ":", suffix1)

arr2 = [10, 20, 30, 40, 50]
suffix2 = suffix_sum(arr2)
print("Suffix sum for", arr2, ":", suffix2)

def count_substrings(s):
    n = len(s)
    substrings = set()
    for i in range(n):
        for j in range(i + 1, n + 1):
            substrings.add(s[i:j])
    return len(substrings)

# Example usage:
s1 = "abc"
count1 = count_substrings(s1)
print("Number of distinct substrings in", s1, ":", count1)

s2 = "hello"
count2 = count_substrings(s2)
print("Number of distinct substrings in", s2, ":", count2)

"""#Domains

#Memoization

Fibonacci sequence using memoization: This algorithm efficiently computes the nth Fibonacci number using memoization to avoid redundant calculations. It stores the results of previously computed Fibonacci numbers in a dictionary (memo) and reuses them when needed, resulting in improved performance compared to the naive recursive approach.
"""

def fibonacci(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)
    return memo[n]

# Example usage:
print(fibonacci(10))

"""Longest Common Subsequence (LCS): This algorithm finds the length of the longest common subsequence between two strings X and Y. It uses memoization to store the results of subproblems, such as the length of the LCS between prefixes of X and Y, to avoid redundant calculations and improve the overall efficiency of the solution."""

def lcs(x, y, i, j, memo={}):
    if i == 0 or j == 0:
        return 0
    if (i, j) in memo:
        return memo[(i, j)]
    if x[i - 1] == y[j - 1]:
        memo[(i, j)] = 1 + lcs(x, y, i - 1, j - 1, memo)
    else:
        memo[(i, j)] = max(lcs(x, y, i - 1, j, memo), lcs(x, y, i, j - 1, memo))
    return memo[(i, j)]

# Example usage:
X = "AGGTAB"
Y = "GXTXAYB"
print("Length of LCS:", lcs(X, Y, len(X), len(Y)))

"""Coin Change Problem: This algorithm determines the minimum number of coins needed to make a certain amount of change. It recursively explores all possible combinations of coins and uses memoization to store the results of subproblems, such as the minimum number of coins needed to make smaller amounts of change, to avoid redundant calculations and improve the efficiency of the solution."""

def coin_change(coins, amount, memo={}):
    if amount == 0:
        return 0
    if amount < 0:
        return float('inf')
    if amount in memo:
        return memo[amount]
    min_coins = float('inf')
    for coin in coins:
        min_coins = min(min_coins, 1 + coin_change(coins, amount - coin, memo))
    memo[amount] = min_coins
    return min_coins

# Example usage:
coins = [1, 2, 5]
amount = 11
print("Minimum coins required:", coin_change(coins, amount))

"""Rod Cutting Problem: This algorithm finds the maximum value that can be obtained by cutting a rod of a certain length into pieces and selling the pieces at different prices. It recursively explores all possible ways of cutting the rod and uses memoization to store the results of subproblems, such as the maximum value obtainable by cutting smaller lengths of the rod, to avoid redundant calculations and improve the efficiency of the solution."""

def rod_cutting(price, n, memo={}):
    if n == 0:
        return 0
    if n in memo:
        return memo[n]
    max_val = float('-inf')
    for i in range(1, n + 1):
        max_val = max(max_val, price[i - 1] + rod_cutting(price, n - i, memo))
    memo[n] = max_val
    return max_val

# Example usage:
price = [1, 5, 8, 9, 10, 17, 17, 20]
size = len(price)
print("Maximum value:", rod_cutting(price, size))

"""Matrix Chain Multiplication: This algorithm determines the optimal way to multiply a chain of matrices to minimize the total number of multiplications. It recursively explores all possible parenthesizations of the chain of matrices and uses memoization to store the results of subproblems, such as the minimum number of multiplications needed to multiply subchains of matrices, to avoid redundant calculations and improve the efficiency of the solution."""

def matrix_chain_order(p, i, j, memo={}):
    if i == j:
        return 0
    if (i, j) in memo:
        return memo[(i, j)]
    min_cost = float('inf')
    for k in range(i, j):
        cost = matrix_chain_order(p, i, k, memo) + matrix_chain_order(p, k + 1, j, memo) + p[i - 1] * p[k] * p[j]
        min_cost = min(min_cost, cost)
    memo[(i, j)] = min_cost
    return min_cost

# Example usage:
p = [10, 20, 30, 40, 30]
n = len(p) - 1
print("Minimum number of multiplications:", matrix_chain_order(p, 1, n))

"""#Tabuation

Fibonacci sequence using tabulation: This algorithm computes the nth Fibonacci number using a tabulation approach, where the results of subproblems are stored in a table. It iteratively fills up the table with Fibonacci numbers starting from the base cases (fib[0] and fib[1]), and then uses these stored values to compute subsequent Fibonacci numbers until reaching the desired nth Fibonacci number.
"""

def fibonacci(n):
    if n <= 1:
        return n
    fib = [0] * (n + 1)
    fib[1] = 1
    for i in range(2, n + 1):
        fib[i] = fib[i - 1] + fib[i - 2]
    return fib[n]

# Example usage:
print(fibonacci(10))

"""Longest Increasing Subsequence (LIS): This algorithm finds the length of the longest increasing subsequence in a given sequence of numbers. It uses tabulation to fill up a table (dp) where dp[i] represents the length of the LIS ending at index i. It iterates through the sequence and updates dp[i] by considering the maximum LIS length ending at each index."""

def lis(nums):
    n = len(nums)
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

# Example usage:
nums = [10, 9, 2, 5, 3, 7, 101, 18]
print(lis(nums))

"""Knapsack Problem: This algorithm solves the 0/1 knapsack problem, where items have a weight and a value, and the goal is to maximize the total value while not exceeding a given weight capacity. It uses tabulation to fill up a 2D table (dp) where dp[i][j] represents the maximum value that can be achieved with the first i items and a knapsack capacity of j. It iterates through the items and weight capacities, updating dp[i][j] based on whether including the current item improves the total value."""

def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, capacity + 1):
            if weights[i - 1] <= j:
                dp[i][j] = max(dp[i - 1][j], values[i - 1] + dp[i - 1][j - weights[i - 1]])
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[n][capacity]

# Example usage:
weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]
capacity = 5
print(knapsack(weights, values, capacity))

"""Edit Distance: This algorithm computes the minimum number of operations (insertion, deletion, or substitution) required to convert one string into another. It uses tabulation to fill up a 2D table (dp) where dp[i][j] represents the minimum edit distance between the first i characters of the first string and the first j characters of the second string. It iterates through the characters of both strings, updating dp[i][j] based on whether the characters match or not."""

def edit_distance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1
    return dp[m][n]

# Example usage:
word1 = "horse"
word2 = "ros"
print(edit_distance(word1, word2))

"""Shortest Path Problems (e.g., Dijkstra's Algorithm): This algorithm finds the shortest path from a source node to all other nodes in a weighted directed graph. While Dijkstra's Algorithm is typically implemented using a priority queue, this tabulation-based approach iteratively updates the shortest distances to each node by considering all outgoing edges from visited nodes. The algorithm maintains a table (distances) where distances[node] represents the shortest distance from the source node to node."""

def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    visited = set()
    while len(visited) < len(graph):
        node = min((node for node in graph if node not in visited), key=distances.get)
        visited.add(node)
        for neighbor, weight in graph[node].items():
            distances[neighbor] = min(distances[neighbor], distances[node] + weight)
    return distances

# Example usage:
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'C': 2, 'D': 5},
    'C': {'D': 1},
    'D': {}
}
start_node = 'A'
print(dijkstra(graph, start_node))

"""#Optimal Substructure

Shortest Path Problems (e.g., Bellman-Ford Algorithm): This algorithm finds the shortest path from a source node to all other nodes in a weighted graph, even in the presence of negative edge weights and detects negative cycles. It works by iteratively relaxing edges to minimize the distance to each node, iterating over all edges |V| - 1 times, where V is the number of vertices.
"""

def bellman_ford(graph, source):
    distances = {node: float('inf') for node in graph}
    distances[source] = 0

    for _ in range(len(graph) - 1):
        for node in graph:
            for neighbor, weight in graph[node].items():
                distances[neighbor] = min(distances[neighbor], distances[node] + weight)

    # Check for negative cycles
    for node in graph:
        for neighbor, weight in graph[node].items():
            if distances[neighbor] > distances[node] + weight:
                return "Graph contains negative cycle"

    return distances

# Example usage:
graph = {
    'A': {'B': -1, 'C': 4},
    'B': {'C': 3, 'D': 2, 'E': 2},
    'C': {},
    'D': {'B': 1, 'C': 5},
    'E': {'D': -3}
}
source_node = 'A'
print(bellman_ford(graph, source_node))

"""Longest Palindromic Subsequence (LPS): This algorithm finds the length of the longest palindromic subsequence in a given string. It utilizes dynamic programming with optimal substructure, where the length of the LPS for substrings can be computed based on the lengths of their smaller substrings."""

def lps(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]

    for i in range(n):
        dp[i][i] = 1

    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    return dp[0][n - 1]

# Example usage:
s = "bbbab"
print(lps(s))

"""Maximum Subarray Sum: This algorithm finds the contiguous subarray within a one-dimensional array of numbers that has the largest sum. It utilizes dynamic programming with optimal substructure to efficiently compute the maximum sum subarray for each index, iterating through the array only once."""

def max_subarray_sum(nums):
    max_sum = float('-inf')
    current_sum = 0

    for num in nums:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)

    return max_sum

# Example usage:
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray_sum(nums))

"""Longest Substring Without Repeating Characters: This algorithm finds the length of the longest substring without repeating characters in a given string. It utilizes a sliding window approach along with a hashmap to efficiently track the characters in the current substring, ensuring no character repeats within it."""

def length_of_longest_substring(s):
    char_index_map = {}
    max_length = start = 0

    for i, char in enumerate(s):
        if char in char_index_map and char_index_map[char] >= start:
            start = char_index_map[char] + 1
        else:
            max_length = max(max_length, i - start + 1)

        char_index_map[char] = i

    return max_length

# Example usage:
s = "abcabcbb"
print(length_of_longest_substring(s))

"""Edit Distance: This algorithm computes the minimum number of operations (insertion, deletion, or substitution) required to convert one string into another. It utilizes dynamic programming with optimal substructure, where the minimum edit distance for two strings can be computed based on the edit distances of their substrings."""

def length_of_longest_substring(s):
    char_index_map = {}
    max_length = start = 0

    for i, char in enumerate(s):
        if char in char_index_map and char_index_map[char] >= start:
            start = char_index_map[char] + 1
        else:
            max_length = max(max_length, i - start + 1)

        char_index_map[char] = i

    return max_length

# Example usage:
s = "abcabcbb"
print(length_of_longest_substring(s))

"""#State Space Reduction

Subset Sum Problem: Given a set of positive integers and a target sum, the Subset Sum Problem asks whether there exists a subset of the given set whose sum is equal to the target sum. It's a classic problem in computer science and has applications in various domains such as cryptography, data compression, and bioinformatics. Dynamic programming is commonly used to efficiently solve this problem.
"""

def subset_sum(nums, target):
    dp = [False] * (target + 1)
    dp[0] = True
    for num in nums:
        for i in range(target, num - 1, -1):
            dp[i] |= dp[i - num]
    return dp[target]

# Example usage:
nums = [3, 34, 4, 12, 5, 2]
target = 9
print(subset_sum(nums, target))  # Output: True

"""Travelling Salesman Problem (TSP) using Bitmasking: The Travelling Salesman Problem is a classic optimization problem where the goal is to find the shortest possible route that visits each city exactly once and returns to the original city. When using bitmasking in dynamic programming to solve TSP, each subset of cities is represented by a bitmask, and the state transition involves considering all possible next cities to visit. This technique optimizes memory usage and computational complexity compared to other approaches."""

def tsp(graph):
    n = len(graph)
    dp = [[float('inf')] * n for _ in range(1 << n)]
    dp[1][0] = 0
    for mask in range(1, 1 << n):
        for u in range(n):
            if mask & (1 << u):
                for v in range(n):
                    if mask != (1 << v) and mask & (1 << v):
                        dp[mask][u] = min(dp[mask][u], dp[mask ^ (1 << u)][v] + graph[v][u])
    return min(dp[-1])

# Example usage:
graph = [[0, 10, 15, 20],
         [10, 0, 35, 25],
         [15, 35, 0, 30],
         [20, 25, 30, 0]]
print(tsp(graph))  # Output: 80

"""Minimum Partition: In the Minimum Partition problem, given a set of positive integers, the goal is to divide the set into two subsets such that the difference between the sums of the two subsets is minimized. This problem is a variation of the Subset Sum Problem and can be efficiently solved using dynamic programming techniques, often involving bitmasking to represent the subsets."""

def minimum_partition(nums):
    total_sum = sum(nums)
    target = total_sum // 2
    dp = [False] * (target + 1)
    dp[0] = True
    for num in nums:
        for i in range(target, num - 1, -1):
            dp[i] |= dp[i - num]
    for i in range(target, -1, -1):
        if dp[i]:
            return total_sum - 2 * i

# Example usage:
nums = [3, 1, 4, 2, 2, 1]
print(minimum_partition(nums))  # Output: 1

"""Optimal Binary Search Tree: The Optimal Binary Search Tree problem involves constructing a binary search tree with a given set of keys and associated probabilities of search. The goal is to minimize the expected search time by arranging the keys in a way that minimizes the average search cost. Dynamic programming is commonly used to solve this problem efficiently, where the optimal substructure arises from the fact that the optimal solution for a subtree depends on the optimal solutions for its subtrees."""

def optimal_bst(keys, freq):
    n = len(keys)
    dp = [[0] * n for _ in range(n)]
    for i in range(n):
        dp[i][i] = freq[i]
    for L in range(2, n + 1):
        for i in range(n - L + 1):
            j = i + L - 1
            dp[i][j] = float('inf')
            for k in range(i, j + 1):
                cost = sum(freq[i:j + 1]) + (dp[i][k - 1] if k > i else 0) + (dp[k + 1][j] if k < j else 0)
                dp[i][j] = min(dp[i][j], cost)
    return dp[0][n - 1]

# Example usage:
keys = [10, 12, 20]
freq = [34, 8, 50]
print(optimal_bst(keys, freq))  # Output: 142

"""#Greedy Strategy

Fractional Knapsack Problem: The Fractional Knapsack Problem is a variant of the Knapsack Problem where items can be divided into fractions. The goal is to maximize the total value of items selected while not exceeding the capacity of the knapsack. It uses a greedy strategy by selecting items with the highest value-to-weight ratio until the knapsack is full.
"""

def fractional_knapsack(weights, values, capacity):
    n = len(weights)
    ratios = [(values[i] / weights[i], weights[i], values[i]) for i in range(n)]
    ratios.sort(reverse=True)
    total_value = 0
    for ratio, weight, value in ratios:
        if capacity >= weight:
            total_value += value
            capacity -= weight
        else:
            total_value += capacity * ratio
            break
    return total_value

# Example usage:
weights = [10, 20, 30]
values = [60, 100, 120]
capacity = 50
print(fractional_knapsack(weights, values, capacity))  # Output: 240.0

"""Activity Selection Problem: The Activity Selection Problem involves selecting the maximum number of activities that can be performed, given a set of activities with start and finish times. The goal is to select non-overlapping activities to maximize the number of activities performed. It's solved using a greedy strategy by selecting activities based on their finish times."""

def activity_selection(start, finish):
    n = len(start)
    activities = sorted(zip(finish, start))
    selected_activities = [activities[0]]
    for i in range(1, n):
        if activities[i][1] >= selected_activities[-1][0]:
            selected_activities.append(activities[i])
    return len(selected_activities)

# Example usage:
start = [1, 3, 0, 5, 8, 5]
finish = [2, 4, 6, 7, 9, 9]
print(activity_selection(start, finish))  # Output: 4

"""Huffman Coding: Huffman Coding is a data compression algorithm that assigns variable-length codes to characters based on their frequencies in the input text. It constructs an optimal prefix-free binary tree (Huffman tree) to represent the encoding scheme, where characters with higher frequencies have shorter codes. It's typically implemented using a greedy approach by iteratively merging the least frequent characters until a single tree is formed.

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA+gAAAINCAIAAAAiP8I2AAAgAElEQVR4AeydvUszT9v37/8ovaQ1YKVYWASsgoWFkEKwEEEbC0PAIpIiYBFFJIWwVkGCqdxGggRSKEm3CJIuSZMuz3Pfc11HjnNmdrPZt+zL9+Lkd42b2Xn5zNt3j5059n8W+B8IgAAIgAAIgAAIgAAIgEDsCfxP7EuIAoIACIAACIAACIAACIAACCwg3NEJQAAEQAAEQAAEQAAEQCABBCDcE9BIKCIIgAAIgAAIgAAIgAAIQLijD4AACIAACIAACIAACIBAAghAuCegkVBEEAABEAABEAABEAABEIBwRx8AARAAARAAARAAARAAgQQQgHBPQCOhiCAAAiAAAiAAAiAAAiAA4Y4+AAIgAAIgAAIgAAIgAAIJIADhnoBGQhFBAARAAARAAARAAARAAMIdfQAEQAAEQAAEQAAEQAAEEkAAwj0BjYQiggAIgAAIgAAIgAAIgACEO/oACIAACIAACIAACIAACCSAAIR7AhoJRQQBEAABEAABEAABEAABCHf0ARAAARAAARAAARAAARBIAAEI9wQ0EooIAiAAAiAAAiAAAiAAAhDu6AMgAAIgAAIgAAIgAAIgkAACEO4JaCQUEQRAAARAAARAAARAAAQg3NEHQAAEQAAEQAAEQAAEQCABBCDcE9BIKCIIgAAIgAAIgAAIgAAIQLijD4AACIAACIAACIAACIBAAghAuCegkVBEEAABEAABEAABEAABEIBwRx8AARAAARAAARAAARAAgQQQgHBPQCOhiCAAAiAAAiAAAiAAAiAA4Y4+AAJxJPA7+fu0+s7/4lhulAkEQAAEQAAEQCA0AhDuoaFFwiBgT0DocmPwVjcfbrr1Uuu01DrdaRzmqgVv/0QKpdZp3Xyomw/vw49Pq2+fP34BARAAARAAARBIHgEI9+S1GUqcOAJCptfNh7JxWWqdepPm3u7K1/ZLrdObbv2x9wIpn7iegwKDAAiAAAiAACcA4c5pIAwCgRH4tPpCqedr+ys1d7F1UmydHBln1+ad+NcYPBtWx/nfbe+e4osUdpullXkdNI8v2pXH3sv3eBRYbZEQCIAACIAACIBA+AQg3MNnjBwyQ+B7PHrsvTjY1Ldqe8XWyXm3cm3eGVanMzZHCyuMf4bVeRq+Xpt35fZVsXVip+bztf2ycWkM3n4nf5lpJVQUBEAABEAABJJKAMI9qS2HcseHwPvw46Jd0e5Q36rtCTu6YXX6858wNLrLNM3Jl5Dydjr+oHlcNx9gho9Pv0JJQAAEQAAEQEAiAOEuAcGfIOCWwPd4dNGuqDththvF7UZRGLldquqIoxlWRxRPu7Vmp3H42HuBDd5tP0A8EAABEAABEIiKAIR7VKSRT1oITOezx96Lal/fbZZue/di98u1eZcI4W5YndHCehq+nncr9LBB+2pKrVNj8JaWdkM9QAAEQAAEQCDxBCDcE9+EqEBkBH4nfxftCulaMlrf9u7NyRe3midLuFPJO2NTVfA7jcO6+TCdzyLjjIxAAARAAARAAAS0BCDctVhwEQT+IaBK9q3a3nm3Iul1UsAJFe5U/qfha7l9xR9R8rV9yPd/+gT+AAEQAAEQAIHICUC4R44cGSaKgCrZd5ulxuCZNK42kHThLirVn/9cm3dbtT1S8JDvieq8KCwIgAAIgEDaCEC4p61FUZ+gCEzns7r5QJo1Vy0UWydiU7hWrPOL6RDuVKPG4JnvgN9pHL4PP4LijHRAAARAAARAAARcEoBwdwkK0bJF4NPq8+On7iW7ELspE+6iUo3BM7e+l41LbHzP1qhAbUEABEAABDZNAMJ90y2A/ONH4KZbJ0P7dqO4cmMMWaYpkErhPlpYYvMMwcnX9mF6j1//RYlAAARAAARSSwDCPbVNi4p5IDCdzw6axyRMz7sVb19NSqtwF08m5uSLf8Xpplv3gBq3gAAIgAAIgAAIrEsAwn1dYoifWgLf4xF9TWm7UXS5nZ2s7DyQbuEuanrbu6cnnFLrFNtmUjswUDEQAAEQAIHYEIBwj01ToCAbJcBVe7F14s3QTto9C8J9tLA6Y5MOrR40j6HdN9qFkTkIgAAIgED6CUC4p7+NUcOVBLhqL7evSH97DmREuItd77vNkjC9Q7uv7GmIAAIgAAIgAAJ+CEC4+6GHe9NAgKt2D+dQteJ+pXDvz38MqyP+aVPgF83Jl4jp8j0AJW73fSjD6gip7Wc7EJWwP/+Bdk/DSEAdQAAEQAAEYk8Awj32TYQChklgOp+R28fb3j2JUZ+BlcKdf5fUIS/JgbrwJd8Zm3a3GFaHHxvNVQvbjeLT8FWKH6xwl+zuF+1KmC2GtEEABEAABEAguwQg3LPb9qj5YrEoG5fC9hzIDhnSx87CnXSzyJrukgJc3IuY9F/tm4HG4JkiSAGpdlSAQCzuotjc7m4M3tC7QAAEQAAEQAAEAicA4R44UiSYGALvww8hcIutE0k0+/zTQbh3xib/jFGuWtDm9TR8lcQ3/3OrtidtgzEnX1KyPH6uWuB29zCE+2hhURnytX0cVE3MMEBBQQAEQAAEkkMAwj05bYWSBk1AbJJRRbBWSa910U64cxeKJKy1KZO3lly1cGScGVbnafhKW8lz1YJkROfm+d1m6Wn4alidI+OMctluFCmjkIT7aGFRBbFhJujeivRAAARAAARAYAHhjk6QUQLG4E2I2mvzjhRtUAFVuD8NX6Xd5ySp1UxJWItN7RShP/+huyRTPV3fqu3xM6xc69PGGEqfrlAW/gNUzd/JX0b7FqoNAiAAAiAAAuEQgHAPhytSjT0B8YVUSeb6l60iBUm4k1AW8lra06JmSrfnqgVpOzu3rJPs5ulLlni+8Z0eUSg+paCWwfMVSrxuPsS+F3gvIH2rS7RpqXXqPS3cCQIgAAIgAALuCEC4u+OEWOki8D0eCb1FWtazTtXeSMpb/EpaNlctbNX2OmOTDOSS4VzEJ6N1rlqQtDWlnKsWqPDai2rWtJWfyiMlrq2Lh4vCzL/TOExXr1nWhl7XUDtCuC/pIAQCIAACIBAaAQj30NAi4RgTeOy9CMklHfH0IFK1t5CSFr+SUD4yzsQ+FhJ8WuHO97fwfS+jhUVJ5aqF825FpH/erVCC/BCq+JV+2m2WpPKEJNxpp3sqd8tM5zPJ3J6rFiDcYzzcUTQQAAEQSA8BCPf0tCVq4p6A8ALJz2sKRRvUf1XhLg6YUvokprXC3eFXLtzJgu5goR8tLDU1SiQk4U6vFFLpF7LUOuVIRRjC3f3oQ0wQAAEQAAHPBCDcPaPDjQkmILQXCV/S0zzQn/+cdyvepK0k3HmyIsyV31q/kubm51Y3KNyvzbtr8056LUBPC+nb5n7RXr7c4I0I4Z7g6QBFBwEQAIHkEIBwT05bxbKk0/ns0+qLfwly3S0kF+0RV6VzY/AsjpDS9hI1jsOVjAj3/vxHUNqq7Z13K3zfkbh+063Hstt6KdR0PqPPdXHJLsIQ7l6Y4h4QAAEQAIE1CUC4rwkM0f+PwO/k76JdEX7QuYjZaRxetCvx39nsINzNyRc3YO82S1yPOoh1/lNGhHtnbHJ/88K7vMAltumXjct0jJjv8Ujt7bznQ7ino6FRCxAAARCIOQEI95g3UByLd9Otc8miDcfc1CpEmOQ5sT//IcEt3L/c9u65HHcfpnTsbuHQ1DgOv8Ztq8xoYTUGz6p8F1VIwVaZ6XzmpsNDuMdxqkKZQAAEQCB1BCDcU9ekYVZoOp9pT+ZxoUnhOEsZdY+7YXW4+jwyzjwY2kmC+xTuDl5ltH7ZHbzKmJMvahHa00/q39sOfqomD2i/MBXz5zfnsfI7+aubD6oDGeLJA3Hu7c7VxK8gAAIgAAIJIgDhnqDG2nxR7U7mcQXDw7H97j3ZUPvzH3PydWScUbG3G0XVoyJXqG7CPoU736sjaWtKOVct0AsBflHauE8aPVctHBlnovB0UUrcTdWc4xhWhxde+En8tPqb77vrl8D9MyrcQa5PF3eAAAiAAAh4IQDh7oVaNu95H36QunUfeB9+xBAX1eXIOOPfMdU6SHGWqtpfSUlrfyWnKwKjGodu5+pcROPPGJ2xKS6SEOfqXPxELtV5UhQ/cOGuFlLUsdQ6TZx8txPu6teXINxjOMZRJBAAARBIJQEI91Q2ayiV0h7O22kcGoO3T6tvDN7sIoRSGt+JSlsgiq0T0sFCffr5Lylvu0T4k48ah/yg56qF7UaRnC3y61u1PX4jf/ygivTnP3z/D10PVbj35z8k1qVXNKXWaTwf5LS9SRXu+dq+ePzgzUeV1SaCiyAAAiAAAiAQIAEI9wBhpjkpMlFzybLTOOQuIKfzmVa7x02rSccNt2p7jcEzF8H+wz6F+2hhccG93Shem3fn3QpX59KWmHL7ippGOGe8Nu94IrTBnX9+NQyLO9VdaFzhgIjKlqsWxMNe/EeLJNwv2hXq7bw6Iow97vFvUJQQBEAABFJAAMI9BY0YRRW0HqzV72JqdxHEyifg+/BDsrV789TuLO5JvNpF48pPG4eM4jwmhbkZXtxOLtUpjhQgc3uowt2cfImni53GIe+XSZTvJNxLrdPv8YhXR2KLrTIcDsIgAAIgAALhEYBwD49tqlJWlUquWiADJFV1Op9pY1KEDQZ+J38kxXLVwkHzmJ5GJOu1VkmvddG/cBduFrmJncBu1fa4CqeCqV7V6RbplQI9FQRucaeTqdod7aqfFmF9VzvSBvsJZV02Lm+6de1HCQgsBWBxJ24IgAAIgAAIhEcAwj08tulJ+dPqk0ChgJ1S4eKYImtlXJSA6uYDFSZf2xf+xafzGVnftVKYNPG6gZXCvdg6oX8OiZuTr3L7ina87DZLzsdnhSt68ia53SiW21eqX8uQhDvV2vkdy3Q+k9wsihaJp3zX9lLqSxSwGw7a23ERBEAABEAABLwRgHD3xi1bdz32XkigUMDO1SN5WqSYuWrhsfeyKWSfVp/vvC8bl9yGSs8kdmZsB1Xt8BNJWIc4G/wpDOFODualkw927Z5o+c77tghDuNs1NK6DAAiAAAgESADCPUCYqU1Kq8XtPorJbdukbzbyIZ7pfEabYcSZSO0xWSpwgNo9a8KdVHu+ti9tB3ceFdP5TPJHJKzv/OHKOYWN/EodmwIQ7htpCGQKAiAAAlkjAOGetRb3Ul/t7hc74a41z0cvax57L7QNJlct1M0Hh50Y5LUwKO2eKeFOqj1XLajnlV12OEm+56qFi3YltvKd9DoFou/hLsEiGgiAAAiAQJoIQLinqTXDqotWuNttW6fNJ6RpIva58T0eHTSPKXfVJYgWE9fuEXw5dYP7ZIL1KnPerRBqz6qdWiQp8p2qTAEId2pEBEAABEAABMIjAOEeHtv0pEzqhAfWEu65aiECHJKD9nxtf6299aTdc9WCTz8zWbC49+c/5EMmX9v3r9qphxiDN+lZ8aJdWWsHDiUVUoAPBBGGcA8JNZIFARAAARDgBCDcOQ2E9QRUmZKrFuIm3N+HH/wQKv9cjr5Wuqt8n89us+TZ1UzqhfvT8JVcVa67r10HXnPt0+pL8r3UOrXrdZr7w7ykjggI9zB5I20QAAEQAIH/EIBwR1dYTUCVKbES7pKD9p3GoR9592n1+eZ4Z/eLdjteUizczcnXkXFGXaLUOnU4PLC6b62KEU/5TtWnAIT7qpbE7yAAAiAAAgEQgHAPAGLqkyB1wgN24li7xz28rTLcIzg5aPfZIpI7mu1GUfqAkZ1ep+upFO7CSTwZ2sWRX5+oXd7+afX5RiZxasKuB7pM0080PhBEGMLdD0/cCwIgAAIg4JIAhLtLUJmOpsqUOFjcJQftpdZpsE5IpL03u82S+++Mpky4q5Ld5ZHfYIfN7+RPku/iw6vB5uImNXVEQLi74YY4IAACIAACPglAuPsEmInbVZmyWeE+nc+4gNtpHGodtPtvG/GRIF59l9b31Ah3VbJvSitTa8ZBvvMuIcIQ7tRACIAACIAACIRHAMI9PLbpSVmVKRsU7pKD9ptuPdQ91ovFQlWK243itXlnTr5ob4wUSIFw74zNcvuKN31QO5ECGRi/k7+bbp2fRojyiYJjgXAPpEGRCAiAAAiAgBsCEO5uKGU9DneLTpLFboexdo/7QfPYP8Tv8Yi7GYl4t4aQ71wp5qqFI+OsMXjuz39SI9zNyddt7367UaSGFh+dfey9hP2A5KGHiFcivFHE00XYReVwINw9NBxuAQEQAAEQ8EYAwt0bt2zdxeUySRY7v93coyJF9rmRwKeD9gBbSyhF7ndS1FFS8ImzuAu9vtssUZOJQKl1atfQAVL1mVT08l2iFPEnxnziwu0gAAIgAALJJQDhnty2i67kZeNSVSp180Fbgrr5oEa+aFe0kd1clA6JenPQ7iajteK8Dz/4PnuqcrF1ctu7p00mkiU+Jn8aVkcU+Nq8O+9WVL2er+3fdOvBHvZdC6+HyNP57LH3wp+pwrO+U3NTwOejqYf64hYQAAEQAIEMEoBwz2Cjr11lrRa3E+433TqpGQrYRXYuSrAO2p3z8vbrdD4zBm/aBxtR92vzzr0vmghkvTn5ehq+0nMFNZAI5Gv7F+1KSCd9vRH2cJcxeOPyPVctXLQrwT6ESNxgcffQTLgFBEAABEDAAwEIdw/QMnfL+/DDvVLR7qux2xDvgJI7aI/SZbhDkRx+Egr+ol3h+605tN1m6cg4Ezre4VRr4NrdsDpPw9dr867YOpF2rlPxDprHN926hzZyALLxn0KV74SOArC4b7zFUQAQAAEQyAIBCPcstLLfOv5O/kigUCBf29emq1Wuax0W/LT6/Dhs4A7atcUO8OL3ePTYeykbl1oUBHC3WSq2Ts67lWvzrjF4NqyOYXW8afrO2BS3X5t31+ZduX1VbJ3wLyVRphQ4aB5ftCvG4C1YU3SAGANJyhi88b4UlPWdMFIAwj2Q9kIiIAACIAACzgQg3J354Nf/EJD2Hgi9ou6p0Nrm3buUkRy052v7ahbJapLfyd/78KNuPpRap846niQgDxRbJ9p/drZzfq8U3mkclo3LuvnwafXXeo5KFnBtaT+tvvQiqNQ69fOGQWKLrTJa7LgIAiAAAiAQOAEI98CRpjNB7TZ31cooySOhb1y6JTEGb1zaRuCgPfqmms5nn1b/sfcipLwWlyoK172y0zgstU4v2pW6+WAM3vwo1OgRhZdjgPJdbRF1LIRXEaQMAiAAAiCQWQIQ7plt+vUqrt0tk6sWysal2GvxO/nTntHM1/ZX2nclB+0HzePv8Wi98iU89u/k79Pqf1p9Y/BWNx/oX9m4LLVO1X9ClFO09+GHuH0l6oRzCqD4n1Zf6qgerO+CNv9v1npsAC2BJEAABEAABNYnAOG+PrOs3qF1F6OaHqUrzv5khAduuiVf23/svWQVMOodHQH1a7hRfng1unoiJxAAARAAgXQRgHBPV3uGWZvpfCad8yPBbRdw3t0uOWgvG5cwGIfZgEhbJgD5LhPB3yAAAiAAAvEmAOEe7/aJWel+J3/aU6pa4Z6v7dt5LJH21ew0DrEPO2ZNnaHiCPnOz1fA+p6h5kdVQQAEQCBRBCDcE9VcMSjsdD5zc6TyoHlsZz5PloP2GCBHEaIgIHZtSfK9bj7YdeMoyoQ8QAAEQAAEQOBfAhDu//LAX+4IqO6xyejuYK1MuoN2d2wQK8EEVPmer+1Dvie4RVF0EAABEEgXAQj3dLVntLUhJ+XCvcn78MNub4zqoN2lj8hoK4TcQOB/CQj5zneFQb6jZ4AACIAACMSBAIR7HFoh5WXIgoP2lDdhVqtnDN4k+X7Rrtg9nWYVEuoNAiAAAiAQHQEI9+hYZzCn38kf3xB/0DzGIdQMdoOkV1mS77lqAfI96W2K8oMACIBAQglAuCe04eJebDhoj3sLoXxrElDPdUC+r4kQ0UEABEAABPwSgHD3SxD3qwQ+rT7fYEBfV1Vj4goIJIvAp9XnL5HEx4PxHilZjYjSggAIgEByCUC4J7ft4lhyOGiPY6ugTEETUOV7qXUK+R40ZqQHAiAAAiAgE4Bwl4ngb88EHnsv3A02nOh5JokbE0EA8j0RzYRCggAIgECaCEC4p6k1N1YXOGjfGHpkvGkC4sOr9B2DXLVw0DyGt9NNNwvyBwEQAIF0EoBwT2e7Rlar6Xx2062TasnX9iFZIoOPjOJDQJXvDl8ii0+xURIQAAEQAIFkEYBwT1Z7xau0cNAer/ZAaTZNAPJ90y2A/EEABEAg5QQg3FPewCFVDw7aQwKLZFNAQPhC5ec9dhqHOPKRgpZFFUAABEBg4wQg3DfeBAkrgOqgvW4+JKwOKC4IhE9Ale/52j7ke/jgkQMIgAAIpJkAhHuaWzfwusFBe+BIkWC6CUC+p7t9UTsQAAEQiJgAhHvEwJOa3XQ+KxuXdAh1p3H4PvxIamVQbhCInIAxeONfJcvX9m+69d/JX+QFQYYgAAIgAAIJJgDhnuDGi6zocNAeGWpklG4CknzPVQsX7Qrke7obHbUDARAAgQAJQLgHCDOFSX2PRwfNYzK0l1qn3+NRCuuJKoFAhAQg3yOEjaxAAARAIFUEINxT1ZwBVgYO2gOEiaRAQCWgfnj1ol35tPpqTFwBARAAARAAAUEAwh09QUPgffjBndldtCvT+UwTD5dAAAT8EVDle6l1CvnuDyruBgEQAIHUEoBwT23TeqsYHLR744a7QMAPAch3P/RwLwiAAAhkhwCEe3baenVN6+YDbWcXPqdX34MYIAACARH4Ho8u2hUag7lqodQ6NQZvASWPZEAABEAABBJPAMI98U0YSAXgoD0QjEgEBPwT+J38SfJ9p3EI+e4fLFIAARAAgRQQgHBPQSP6qgIctPvCh5tBIBwCkO/hcEWqIAACIJBsAhDuyW4/n6WXHLTfdOs4hOoTKW4HgQAJ/E7+6uYDPym+0zh87L1gnAYIGUmBAAiAQIIIQLgnqLGCLOr3eFRqndJuWjhoDxIu0gKBQAlM5zNJvosjKJDvgWJGYiAAAiCQAAIQ7glopGCLqDpof+y9BJsFUgMBEAicAOR74EiRIAiAAAgkjgCEe+KazFeB34cfO41DMrTDQbsvmrgZBCInMJ3PpA+vCuv77+Qv8rIgQxAAARAAgagJQLhHTXxT+UkO2ncah/jIy6baAvmCgH8CknzPVQsX7Qrku3+wSAEEQAAE4kwAwj3OrRNY2fgGWThoDwwrEgKBTROAfN90CyB/EAABEIiUAIR7pLijz0xy0F5qncImF30rIEcQCJXA+/CDnzUX1vfv8SjUTJE4CIAACIBA9AQg3KNnHlGO0/mMf8Zlp3H4PvyIKG9kAwIgEDmBT6svyfdS6xQ74iJvB2QIAiAAAiESgHAPEe4Gk4aD9g3CR9YgsEECkO8bhI+sQQAEQCBsAhDuYROOOn3JQftB8xhvzKNuA+QHApsm8D0e8RduuWqh1DrFO7dNNwvyBwEQAAG/BCDc/RKMz/1w0B6ftkBJQCAOBH4nf5J832kcGoO3OJQNZQABEAABEPBAAMLdA7Q43iI5aC8bl/iqYhzbCWUCgcgJQL5HjhwZggAIgEBYBCDcwyIbWbq/k7+ycUnfVIKD9sjIIyMQSBCB38nfTbeer+3zucIYvOEJP0GNiKKCAAiAAIR7svsAd9Ceqxbq5kOy64PSgwAIhElgOp/x53zhOPLT6kv/wiwC0gYBEAABEPBOAMLdO7vN3vlp9Q+ax2Q8g4P2zTYHcgeBmBD4nfx9Wn1j8FY3H2669VLrtNQ63Wkc0lyxbkCkUDYu6+ZD3XwQEj8mlUUxQAAEQCBrBCDck9fikoP2fG0fziKS14ooMQgEQeB38vc+/KibD2Xjkj/Jr6vOPcTP1/ZLrdObbv2x9wJv8UE0JtIAARAAgdUEINxXM4pVDGPwxnep3nTr2KIaqwZCYUAgVALT+ezT6tfNh1LrlE8FWuW9Vdsrtk6KrZNy++ravBP/noavhtVx/keRr807kcJus6TNgl88aB5ftCvG4A2fZw61DyBxEACBLBOAcF+2Pr1WFq+GY/hfyaK20ziMYSGDLRKc0C87KEIZJiDEujQDcNG83SgWWyfX5t1t796wOubka7SwAv/Xn/8YVudp+Hpt3pXbV8XWCS8DD+80DoWIh2Uhw90WVQcBEAieAIT7kqn0tXC+CCG8KQJ4Bb/soAhlj8D78OOiXXG2rBtWpz//CVyju0+wMzYbg+fzbsVOxx80jx97LzDDZ6//osYgAALBE4BwXzIVwp1eLosXxO7/u90oCnXr/pZ1Y27V9nLVgucSrpudn/g+adB7eQj3ZQdFKDME7PT6dqNYbl81Bs/m5OvavBMTjnuFHUFMw+qIUtEQ5s/8UPCZ6cKoKAiAQFgEINyXZIVwL7ZOvC1vEayjwqDluYTe6uXtLp80aPmHcF92UITSTuB38lc3H1QPMMXWyW3vXtr94nOIeRvXK++ikWtYndHCehq+lttX9BhPIr5sXOJIfdq7M+oHAiAQCgEI9yVWCPeVq7L7CD5VBS3/EO7LDopQegl8Wv2LdoV0rQgUWyeNwbPdNhifQ8z9WF4rJo1cIdzp3s7YPO9WxDtDquZO4xBfgEpvp0bNQAAEQiEA4b7EyoW7WGaktYcWIQr05z/l9tXT8HW0sCJYRxNqcTcnX7e9+9vePXGzC5x3K0Kp0PIP4b7soAilkcCn1RczD8nZ7Ubx2ryT7OvqkIlgwlEzXXmFRq7d5Pk0fD0yzqiyuWohX9uvmw84w5rG3o06gQAIBE8Awn3JlIS7OfkS60q5feW8UDUGzyJmY/AcwTqaUOEuXpRvN4rOMDl2Wv4h3JcdFKF0Efid/EmSvdg6EVYA55Eifo1gwnFTDCkOjVw74S7iiz363ACfr+0/9l7S1cKoDQiAAAgETwDCfcmUhPtoYQmJvFXbk5Yl6U+K1p//RLCOJlS43/buxeON81rOo9HyD+G+7KAIpYXAdLoO7L4AACAASURBVD676da51bncvnIeHdLME80rPjXTlVdo5Lqpjpg2uXzfaRxiyKelm6MeIAACoRCAcF9i5cKdm9Lt1ipuIY5mHU2ocJdA2fHkhnla/rGKLzsoQqkg8D784O4di62Tzti0GxQO1yOwFDjkbvcTjVw3wl0kosr3i3YFO2dS0dlRCRAAgeAJQLgvmXLh3p//CHvYkXFmt0SRhRh73FVEkqqgVxNqTHGlMzYF8PNuZbSwaPmHcF92UIQSTmA6n/ETqNuNont1qw4caYipETZyhUbuulXrz3/Ou8vjuTC9J7yzo/ggAAJhEYBwX5Llwn20sMrtKyEl7bw6CEfFtHU7gnU0oRb30cJa+QaD1mxhfaTlH8J92UERSjKB7/GIf/f02rzzKawjmHA8lJBG7rrCXeTVGZvcAXzdfEhym6PsIAACIBA8AQj3JVNJuD8NX4Vw17pDkSzE2CojrfGSqlj5BkPsc91tlkQ6tPxDuC87KEKJJfBp9Wl7zG6z5G1vjPMQk37d1J80cr0Jd1Fsmj1y1cJFu5LYZkfBQQAEQCB4AhDuS6aScB8tLElN8rVQshBDuHM4WhrkA059g6E+I9HyD+G+7KAIJZOAMXgTJoBctVBuX6n9Xxo7Lv8kdesyfjTRaOT6Ee5isxwdWj1oHmPLezL7PkoNAiAQPAEI9yVTVbiTOld9KouTlGQh1krVwFfK5G6VEd9QtHuDQbuSiDMt/xDuyw6KUAIJcNWufXfneZZIt3AfLSy+bQbaPYF9H0UGARAIhQCE+xKrKtzV/TBilVUtxBDukv7QqgrtGwztLhoI92W/RCixBD6tPtnaG4NnaYz4/FM7xHym6f92Grk+Le6iJP35D215x56ZxI4DFBwEQCBIAhDuS5qqcB8tLO6jkFY11ULsTbj35z9Pw9dr8+7avLvt3a9c6hJtcefnfcmybndulZZ/WNyXHRShRBH4nfzRvvbAVbvLCYeeiun5QQqocw4JZSmm+HPlmVoauWrKNH+uFeDaHWdVEzUCUFgQAIFQCEC4L7FqhTv5fKR1qD//EZZjyVPkugawp+ErbeKkNdJ5gfcv3OldQa5a0K7BPAKVigdcLrpaGto3GGLv+1Ztj+/9peUfwn3ZQRFKFAHyIRPsDhkagNohRr+KAI0jPoR5mKY1upH/qoa1kwbdyx25qinzaGuFacrNVQuYEBI1CFBYEACB4AlAuC+ZaoW7+vEgO8+GbtZRWq74UsRXR2d3Ez6Fu5Spdg2mWvBS8TBVwTlA6UjRpDcYKl4RnwQH1ullB0UoOQQeey9i1EiP99Jw8POn3RDjaVIcPoR5WJLXNO54HB7WTho8R0pBSpnH8RCmZ/6dxiEOqiZnHKCkIAACwROAcF8y1Qr30cIS7463antivdFaiF2+uaYVi9S/WBTPu5Vr867cvqII2oBP4U5+XUSm2jVYZMGXaimsLZh6kRSD9BNdF48o9EJDfMSKItPyD+G+7KAIJYTAdD4Tm2S2G0X+Hom6dyABGkoOqUlDXhrLuWpBktc0HtWY4op20uAFoJErpczjeAtTfbFhJiHjAMUEARAIhQCE+xKrnXAnkd0YPNtZiNcV7rQI5aoF8a1QN4uZH+GuLsnaNVjdvSMt4W7K6UBDAigeiugjVpQ4Lf8Q7ssOilBCCNTNBzFqnHe+UW/3FqA5xOF28YJLFMb5bZ5IhE7v5KoFbzt8aOQGLtzpxFG+tg+je0KGAooJAiAQPAEI9yVTO+FOB7yOjDOSv5KF2EGqapdVWnTt9ppr7/Is3M3Jl6rIVeFOqjpXLdAbBm1JVl6kCqox6Q0Gvf5WH11o+YdwX3ZQhBJCgMztaucP8IrDEBO50MTlfjjzk6luhL5aHRq5YQh3sqEYg7eE9AUUEwRAAAQCJgDhvgRqJ9xHC4veONtZiN0Ld8PqXJt3fEdKsXUiHMusXOo8C3eeHVnQVeHOT6b63JvroCpo9SWVoEoEWv4h3JcdFKEkEHgffkRgbncz4dAgylULxdaJKrLVKzQ55KoF9Vc3VyjTlbOZm9TUOOIdQql1moS+gDKCAAiAQPAEINyXTB2EO1e0dptbHKQqX34oGl8jRVhV0vzG0cLyJtwpx63aHn8VrmZHMdd6DyAVUvxJSam/ckNgrlrgH7GiyLT8Q7gvOyhCSSBw062L4Rze7vaVQ0yKkKsWjowzsj5sN4rX5p1aPBp0YlSW21fiNZ2YN7gLVxqnaoASCUm400fxsFsmCaMBZQQBEAieAIT7kqmDcB8tLL7VRLUQuzGAqauppN1VJS2tix6EO21HEZtWSU9rpTk3zJ93K2QR322W1t2tSxlJVRB/koaw20pLyz+E+7KDIpQEAs7TiHY4eLvoPMT4e0JpnhF/bjeK0jxG+wC18bdqe24mARq5boS7+JDFWtUnGwpmhiSMBpQRBEAgeAIQ7kumzisu2aq1FmL3wj3KrTL82yXiXTkt9lrhzh9O1MW72DpRrXR2iy5lpI1Aq2+uWtBa8mj5x/K87KAIJYGAGDjqsQ3tQPBz0XmI0VFOdSDTFenjCTTFUQQ1sFKO08hdGZM+vibeAGjnAZUPncN57L0koTtEUcbfyV+pdcr/4QxAFNyRBwhsiACE+xK8s3AnrWm3JK9cR/kiRJG1AprH5OF1Le70WplWaId8aUVUV2u64nKn7MrHGNotY/cURMs/hPuygyKUBAJisKx8e0bjuj//KbevXMpWumvlEBstLBq2uWphu1EUPmf5WzVp1x//SWyPET5qeTp2A5YKRiPXjXDnOYr9POqhf0qZAqI8cApJo4G8GFFLAQ7BQQAE0kcAwn3Zps7CncxRqu9CsaKQJqYFxiFAkcMT7rSC5qoFWg4d8uXxxSZXcWSWe5TjSTnUbqWqoPOpsLgv+x9CqSAgxJNL4W5YHfGaa6UgVocbjWX1p9HCMidf5fZVsXUiJDh/V8a3xHDnUefdSrF1st0o7jZL/EGCb7fLVQvSBhspd5pG3Ah3c/J1bd5JM8xKAzyEOx8ov5M/4cWIVHuuWoBw54gQBoGUEYBwXzaog3CXvjmqXbqc11FpeaPIIQn3/vyHlkPuH8YhX8PqHBlnwgYmuXDmW9J5alKl+J+UEb9IYZ6gVuLQ8g+L+7KDIpQEAu6FO40R4fWFa2saKQ4But0hjt1PfFOcdjaTbuQDVpocpJg0ct0Id7r3afjKsxAMj4wzsjhQTHqTAG0qRsNB85hLdhEGnCRMFSgjCHgkAOG+BOcg3LmFOFctaD9xutY6SpFDEu60CkrfbvSWLze5cRMdX02lMGUkXRe2QL7SaN9g0PIP4b7soAglgcBO41Ds+lB7Pl0xJ1908nutGYBSWPlSi8dUw3yPihuFTcN5ZWlp5LpJViqYGwM8pf8+/EhCdwi3jBftCp9LKQzhHi53pA4CGyUA4b7E7yDcSQeL5VYrXmltk1Yj7Z8UeeVCyG8Xy62bjeY0g7sJ8Czswjwduzj8OlWQXxRhelNP6kG1+dHyDOG+7KAIJYFA2bgUe8rVni+uPA1fyeC93Sh6ELgiHYchNlpYnbF5bd6ddyvaMzk09HLVgiiAOfm67d2LT0yoJae8Vs5XNHI912u0sBwM8DR7/E7+ktAdwirjdD6zU+3YKhMWdKQLAvEgAOG+bAc74U6nNsvtKzK9q+9waW1Tlz31CkVeuRDye0MV7k/DV3EWTev0LUDhLh5+thtFDpZXc7SwaPmHcF92UISSQOCx9yIGi/o4Ks6h0lA6Ms7W3R7DhwnNIfwihelMjnqMhI6Gi5KIMtDMlqsW1BmAvx9Qpz7KlI9cP8JdJNif/9z27mnLH3HLVQs7jcMk9IWwyvg9Hml3yBAiWNzDQo90QSAGBCDcl41gJ9zJxvM0fKU1T93q7byO8rWNv+aOj3CnBVLdu0Iedey+lyTVjldQ+ol23QhDoN0bDAj3Zb9EKFEEfid/Qj9JG+o6Y5PLX+ed4tKo0f7pPOFwIS49IXBNT6/v6ClavC7gh1N5UuSfSlukYIU7ZWFYHV7m/+A1LrO5W6ZuPqinUUmyiwCEe6LmDBQWBNYjAOG+5GUn3CVxSdtmJGuZ8zpKi5AIUOSQhLtwCKP+l78iL7ZORARRJL408gOj3Bm8+9JSBaWKk4dKYY8kTSCZ8SDcl/0SoaQRELtluKn7tndP22N2myXVGC8NEzd/2g0xupcexYUW1zqJ4nZxPgNs1fa07iP5zEAZ8QCNXJ4yj+A5LE1EQqHma/s33XpGts0YgzdxgkKS6eqfEO5JmzNQXhBYgwCE+xKWVrhLFmKx/1JMlNIL5ZXrKF+xKLJ7KTxaWO63yvC8eNghX25yE24uxB5ZEhy5amGlvY3yoozoiggIMUHO7+zeYNDyj60yyw6KUEIIfFp9MUUIUzc96otz7dIDvzRA3P9pN8QoBf6iTNV26iF7c/LFB7t6y26ztLLwNHIDF+6U8kHzWN3eXWqdpvurQyut7Ly9INwTMlWgmCDghQCE+5KaVrhLFmKxKIrljdSnuLhyHaUFle8kiY9wHy0sqixfA3hYelbhNZLCWhqkJPg+AZI1XBPQIg3hvuygCCWHABndyey9VduTXitJQ2bdP7VDTEqkMXi20+LaQ6udsUkF5gPfvcNKGrnBCndubhf29el89th7kSzQKTbAS81Bf6rPMDicmpx5AiUFAS8EINyX1LTCXSxj0rZveqfMd4K6WUdpWaXIsRLuDtp9q7bnXrXzJxOq8mhhabmRmufp0/IP4b7soAglhwDtdBcCS/qkER8UnsM0hzinYE6+zrsV2l6/3SiW21cOqlocCaU9dVu1vSPjjI9N5+xo5Dpk4ZyC9leaOlRb8qfVV8Vr+gzwpNQpkK/tvw8/6PUOXYdwT848gZKCgBcCEO5Laqpwp0WIW4iFqzUxS/Idny7XUbEsNQbPxdaJ+Od+UfS/VcZNvuIoGBnedpul826FP6JoV1bpokqDPmJF5+HoFvUNBpGHcF92UIQSQuB38icmEzFLuN9gRiPCTUAdYm7uCjsOjdwAhTvV9KB5bNcFUm+A57o8Vy2UWqfizQOEu12XwHUQSCsBCPdly6rCncw8qmxVLfG0uoS3NPoX7uGVTUpZpUHnUNUHFZUzLf8Q7ssOilASCLwPP9TtyG52h0sjaOWf6hBbeUsEEWjkBiXcad7I1/bdHEJNqwGehPtO45DPihDuSZgVUEYQCJIAhPuSpirchSVYtRDzrSDkICKCdTTRwl27l10oCVrs6Q0GXeFL1LKpEAKB+BGYzmc33ToJrFLrdDqf0Wb3wHfLRDDheBD6NHIDEe5Ux3xt/3s8ct/m0/nMGLxJzs4TvQP+fw8T6zxgQri77xWICQLpIADhvmxHSbiTpUe1EI8WFvlgIW/NtMZ4WO1c3pJc4a7ikqosvcGg5R/CfdlBEYoxAembOI+9F1HY6XxG8nGrtkfP+VL/9/BnBBOOh1LRyPUp3PnHqtZV7bybfI9HF+2K9A4kiTvg7d42QLjz5kYYBLJAAMJ92cqScHewEIv1TPLvHsE6mlzhzj9ipVUD5NBGKBta/iHclx0UobgSMAZvJA13GoeqbZifnpQOzGiHg5uLEUw4boohxaGR60e4849V+VHt1F/sDPAX7YraWHRXIgIQ7oloJhQSBAIkAOG+hMmFO/kXJ4O6tD6NFhaZ5IWXtwjW0eQKd+khR4UpmeRp+YdwX3ZQhOJHgG+GyVULF+3KdD7TFpPvoim2TtRjM+qgcL4SwYTjXADtrzRyPQt3/rGqg+ZxsMJaa4A/aB4bgze7htO2ZnwuQrjHpy1QEhCIhgCE+5IzF+4rLcSjhUXi/sg447vetetZIBcTKtxJlGtdRxMZLu5p+YdwX3ZQhGJG4Hs8Ij/i+dr+yg8A8XOrW7U9n6b39An3ztgUU5w4J1A2LkMS02kywEO4x2xWQHFAIHQCEO5LxFy4cxFJylIN8O00EayjCRXu0jYYFaO4wh+WINyX/RKhWBKomw90DvWgeWy3BVkqu+QpcrtR9GyZjmDCsRuqDtdp5K5VL76jPVctuHkKksB6+zMFBngId29Nj7tAILkEINyXbUfCnUzpzhZiabdMBOtoQoW7eAqSPmKlrv0cOy3/sLgvOyhC8SAwnc/EXCGE+023vm65HnsvtCdefJR0LZkrxk4EE446SFdeoZHrskb9+c+1ecc/71o2Ll0+Ba2L3S5+og3wEO52zYrrIJBWAhDuy5Yl4S62wdz27t3sQ6VoEayjCRXuo4X1NHx1s5A3Bs8iGi3/EO7LDopQDAjw7S7i05XeCjWdz/iJVSHfxWmZleI4HcJdfNKVS3bJQ7k3sH7uSqIBHsLdT4vjXhBIIgEI92WrceHucu3k0SDcA6QB4b7slwjFhgA/YCrctPss2u/kT5Lv243ibe++P//ho0kbjmDC0ebrfJFGrsODumF1aJOheGux0zhceULAJ2r3twsDPH+pInbvxNMFDYS7+5ZFTBBIBwEI92U7Qrg7L8lr/epTVdDyD4v7soMitDkCv5M/cseeqxbq5kOAZVHle65aODLOnA3wPofYWsPZfWQauapwNydf1+ad+GIDHQ+IlWSX2vR38nfTrfNNTblqIW4uaCDcpVbDnyCQegIQ7ssmFsJ9t1kyrI6Hf+X2lViNPNzr8haxWdxzCV3mEkg0nzTooCqE+7KDIrQhAivdtAdSrt/JX918kGTiVm2v3L7SKvikCPfO2Lzt3Yu5i/S63XdAAyEZeCLG4E1rgI/D7AThHnhzI0EQiDkBCPdlA0lTM19jEN4UgTgsjcsuglDGCEg70cNzUMi5GoO3snGpjrgj4+y2d0/fXo25cL827867Fcm+nqsWdhqHdfMh4uOnHK/nsNYAv9M4fOy9hOS20k1RIdzdUEIcEEgTAQj3ZWtCuKtaYeNXINyXHRShaAms66Y92NKJndZaBb9V2zsyzsjluft9LKHGNCdfT8NXetUmTR07jcObbj3YrykFC9x9aqoBXnx7ayOTFYS7+4ZDTBBIBwEI92U7fo9Hn1Yf/2JFYIOmrGXPQCh7BB57LyQ9A/9+51o4hYK/aFekXTRUvN1mqdy+ujbvDKvjxhFWUPLdsDqNwfO1eVdsnXDnMFQwsSO8bj6kQ69LrRYTAzyEu9Qu+BMEUk8Awj31TYwKggAIrEHAv5v2NTJbM+r3ePTYeykbl3YiXojm3Wap2Do571auzTvhYtWzpqcTL9fm3bV5Jyz9djJd5H7QPL7p1t+HHxl56t6sAR7Cfc0xhOggkHgCEO6Jb0JUAARAICgCn1afNLEfN+1Blcchnd/JnzF4u+nWS61TKjO3djuHhbgvtk6kf86iXJvmQfO4bFzWzYeN7BVxQBTlT5sywEO4R9nKyAsE4kAAwj0OrYAygAAIbJ5A3XwgYVpqnSbrAOV0Pvu0+o+9l7r5UGqdhnRiZ6dxWGqdXrQrdfPhffiRyj0wPjui9mzxRbsS0lMNhLvP9sLtIJA4AhDuiWsyFBgEQCBgAqG6aQ+4rGsm9zv5E6dWjMFb3Xygf2XjUuh76b833TrFEUZ0cfua2WY9unDuudM4pEdB4VEncBc0EO5Z72qof/YIQLhnr81RYxAAAUbgffhBW012GochWUZZhghmiMD78EN1DRSgAR7CPUOdCVUFgf8jAOGOjgACIJBRAhtx055R1tmutp0B3r9Lewj3bPcs1D6LBCDcs9jqqDMIgMD3eHTQPBY7GfK1/cfeC5iAQNgEtAb4snH5PvzwljWEuzduuAsEkksAwj25bYeSgwAIeCQQHzftHiuA25JMIEADvEiKH0vIuHufJPcLlB0EXBGAcHeFCZFAAATSQWA6n/E9xxftSkbcjaej+VJWi8AN8Cnjg+qAAAioBCDcVSa4AgIgkE4CCXLTns4GQK10BAI0wOuSxzUQAIFUEYBwT1VzojIgAAJ2BLib9oPmcbLctNtVCtfTRAAG+DS1JuoCAiERgHAPCSySBQEQiAuB38kf/yBR3XyIS8lQDhBQCPxO/h57L6oPeP8uaJSscAEEQCB5BCDck9dmKDEIgIB7AtxNe762Dzft7tEh5mYJfFr9i3aFf8IpVy34cUGz2eogdxAAgUAIQLgHghGJgAAIxI7AdD676dZJ95SNS5xDjV0joUCrCEznM60B/qZbx3avVfDwOwikkACEewobFVUCARDgbtpz1QLctKNLJJ2A1gBfap0ag7ekVw3lBwEQcE8Awt09K8QEARBIBoHH3ku+ti9s7QfN4+/xKBnlRilBYBUBrQE+X9uHAX4VOfwOAikhAOGekoZENUAABBaLBdy0oxtkhAAM8BlpaFQTBCQCEO4SEPwJAiCQVALf4xH54sjX9rGFIKkNiXK7JgADvGtUiAgCKSEA4Z6ShkQ1QCDjBOCmPeMdIOPVhwE+4x0A1c8OAQj37LQ1agoC6SQwnc+4m/abbj2d9UStQGAVAWGAP2gekzOlXLWAHfCrsOF3EEgSAQj3JLUWygoCICARgJt2CQj+BIHFYvE9Hl20K3REW+h4uKBB3wCBFBCAcE9BI6IKIJBRAtxNe6l1CjftGe0HqLYNgel8ZgzetAZ4uFqyYYbLIBB3AhDucW8hlA8EQEAlADftKhNcAQE7AloD/EHz2Bi84XHXDhqug0A8CUC4x7NdUCoQAAFbAsbgjfYA7DQOYTu0JYUfQIARsDPAX7QrGESME4IgEGsCEO6xbh4UDgRAgBOYzmcX7QodvCsbl7AXcj4Ig4AbAjDAu6GEOCAQTwIQ7vFsF5QKBEBAJgA37TIR/A0CPgjAAO8DHm4FgY0RgHDfGHpkDAIg4J7AY++FDO0HzWO82XePDjFBwJkADPDOfPArCMSKAIR7rJoDhQEBEJAJwE27TAR/g0AIBGCADwEqkgSB4AlAuAfPFCmCwGYJTOezT6tfNx/EP2Pwllz79KfVp3Oo+dr++/Bjs2yROwiknsDv5O+mW6dxJ950wQVN6tsdFUwKAQj3pLQUygkCqwl8Wn3+DVHaWyK+nlg3H5J1lBNu2lc3OWKAQGgEjMGbNJ/ka/twQRMabyQMAq4IQLi7woRIIBB/AtzdCpfsPJyv7SfC+v47+eNfjambD/HnjxKCQCoJaA3wO43Dx95LsgwBqWwdVCqDBCDcM9joqHIKCXCZy5W6Nvxp9eOMQHLTHvPSxpkkygYCARJQDfC5auGiXcEIDRAykgKBlQQg3FciQgQQiDsBvqVEq9Sli/na/u/kL4a1gpv2GDYKigQCnAAM8JwGwiAQPQEI9+iZI0cQCJLAp9WXdLmbP0ut0yALEURa3+MRvTfI1/Yfey9BpIo0QAAEQiEAA3woWJEoCKwiAOG+ihB+B4F4E5BOjwnVftA8Fu+vp/NZ3XzQSvlYveCGm/Z49zKUDgT0BGCA13PBVRAIjQCEe2hokTAIhE/gd/KnivJ8bV86NKbV7hftSvgFXJ3DdD4rG5dUi5tuXSr86iQQAwRAYNMEYIDfdAsg/6wQgHDPSkujnqkkoN3dftOtS5WdzmekjHlg4xIZbtqllsKfIJBoAr+Tv7r5sNM45PMMXNAkuk1R+LgRgHCPW4ugPCCwBgHaFM6XSa3DR27Vpsib/Z4Rfw9Qap3G87zsGo2BqCAAAv8l8D78UOccuKD5Lx78Pwh4JwDh7p0d7gSBjRMgCc4D2lJxlUyRN+UfHW7atW2EiyCQMgIOBng8qKesrVGdyAhAuEeGGhmBQMAEtP5kDprH2my0kTfiW+Z9+EFfU8/X9mN1RlaLDhdBAAR8EtAa4MvG5WZf+vmsFG4HgY0QgHDfCHZkCgIBEDAGb2Q7p4CdFtcK953GYQDlcJ3EdD7jm/LLxuXGN9m7LjsiggAI+CVgZ4Cvmw8wwPuFi/szQwDCPTNNjYqmjoB290vZuNRWVOt/JlctaCOHcZG7ac9VC3DTHgZkpAkCiSAAA3wimgmFjCcBCPd4tgtKBQKrCXDrNVncHbatUxweiMbm/dh7oe0xB81j7fHZ1RVGDBAAgRQRgAE+RY2JqkRHAMI9OtbICQSCJaD99NK6wj3sLeaSm/aLdiWaR4VgUSM1EACB8AjAAB8eW6ScPgIQ7ulrU9QoKwTiL9w/rT55dM7X9nEQLStdE/UEgfUJwAC/PjPckUUCEO5ZbHXUOR0EYi7c+Rb8g+YxDp+lo9ehFiAQNoFPq3/RrvAdfblqAS5owsaO9JNCAMI9KS2FcoKATCC2wn06n/GyqV9ylWuCv0EABEDgXwLT+eyx90Kv7ISO32kcwgXNv5zwV+YIQLhnrslR4dQQ4OKYrFMb3+MON+2p6WCoCAjEgYDWAF9qnRqDtzgUD2UAgYgJQLhHDBzZgUBgBGIo3Lmjm1LrFOdQA2tsJAQC2SagNcDna/s33Tq24WW7a2Su9hDumWtyVDg1BGIl3OGmPTX9ChUBgTgTgAE+zq2DskVAAMI9AsjIAgRCIcBPf3reKhNIyYzBG7lp32kcwk17IFSRCAiAgB0BGODtyOB66glAuKe+iVHB1BLQCne7L6d+Wn0S9zzgkw7ctPsEiNtBAAT8EIAB3g893JtEAhDuSWw1lBkE/peAMXjjElyES61TLR2tcD9oHmsju7z4PR6Rz4d8bR9nxVxyQzQQAIFgCcAAHyxPpBZnAhDucW4dlA0EnAispcW1Kt/OPO+U639/4/b+g+Yxtsf8Fwz+HwRAYGMEvseji3aFdu6ROcMYvH1afRyX31jDIOPgCEC4B8cSKYFA5ARUi3uuWtCWgutsusvBd6Q2EXERbtod4OAnEACBaAh8Wv1Pq183H+rmw0W7UmqdllqnB81jmt/cBPK1fXFjqXUqkhISH55qomlE5OKBAIS7B2i4BQTiQkC7Sr0PP9TyaWN+Wn01pvOVT6tP1qx8bV+bl3MK+BUEQAAE1iIwnc+ERhcCnaYgN9LcT5yD5rEQ9MbgDS8V12oyRA6PAIR7eGyRMgiEdE2ZtQAAIABJREFUToD7Taf16aJdkTL+nfzRrxTI1/alaCv/5NnBTftKXIgAAiDgmYBQ6mXj0o1M36rtFVsnxdbJkXF2bd5J/56Gr4bVMazObe9e+um8WxE37jZLNDc6BEqt05tu3Ri8wSTvuWVxo08CEO4+AeJ2ENgkAa0iz1ULknGobFyqS9FNt+6+6L+TP26z97bHxn12iAkCIJBBAkKsa79QIWYwIdDL7atr807I8f78Z7SwAvzXGZsk8Yutk+1GUZ08xZWdxuFFuwIRn8GOutkqQ7hvlj9yBwG/BLSLXL62XzcfPq3++/BDGyFXLbi3GMFNu99Gwv0gAAI2BKbzmTF4U0+UCnG83SgKI7phdczJV4ACfa2kDKvTGDyfdyt2hvmD5nHdfJAsJjY1xmUQ8EUAwt0XPtwMAhsn8D0e2RmEHK67NLdP57OLdoXSKRuXcMuw8RZHAUAgHQTehx/al4FbtT0x5zwNX9eS15FFFvKdykkzZK5a2Gkc1s0H92aRdDQlahElAQj3KGkjLxAIhYDW1SNfS6TwQfPYjf6Gm/ZQWguJgkC2CfxO/m66dXXn+pFxdtu7NydfhtURU5ZhdSLT4mtlVGyd5KqFYutktLCehq/n3Yq6o6bUOsWnLbLd08OqPYR7WGSRLghESUDr7VHS6+LPncahm/e5j70Xuh1u2qNsSuQFAmkloN25d2ScNQbPfKt6soQ7Kf7O2FQVvNi16MZQktZGR70CJwDhHjhSJAgCmyHwPvxQjVgkvkXAjSuY6XzG31/fdOtYdTbTosgVBNJCwBi80VeWxVy02yzd9u65XicFnFDhzstfbl9Jc+9Fu4L9M2npzhuuB4T7hhsA2YNAgATEd7+5+xexeORr+2Xj0o3XdrhpD7A5kBQIgMCn1Zcke7l95bwHJunCXSj4/vzntncvbaGBHQQjwj8BCHf/DJECCMSRgPis4KfVd2/m4fttSq1T9zfGsf4oEwiAwEYJ/E7+JJdW5faVG88w6RDuZIBvDJ65fM/X9h97LxttGWSebAIQ7sluP5QeBAIhADftgWBEIiAAAoIAtwLkqgWXkl2I3ZQJd1EpSb7j4BBGimcCEO6e0eFGEEgJAb45fqdx6GZHTUpqjmqAAAgETeB7POK79YqtEzdWdrJPjxZWKoW7qOBt7547kcSX7ILufZlID8I9E82MSoKAlgDctGux4CIIgIA3AvxjbVu1PW+O2FMs3EcLqz//OTLO6OiqG4cB3toCd6WVAIR7WlsW9QKBFQQkwxi2Xa7ghZ9BAAQcCdx066RHj4wzrccYblm3C6dbuItaPw1fyfTu0kWvI3v8mCECEO4ZamxUFQSIwGPvhXxHYrclYUEABEDAGwH6xPJWba8xeLYT5W6uZ0G4C9O7+AJrrlrI1/bdfF7DW9PgrpQRgHBPWYOiOiCwgoDkpv2iXYGb9hXI8DMIgIAjAa7aO2PTjTp3iJMR4S4IkMd3aHfHLoYflwQg3JcsEAKB1BPgPpXztf334Ufqq4wKggAIhEqAVPtus+Rftaf7cKr2cQXaPdT+mb7EIdzT16aoEQjoCXAHbQfNY7hp12PCVRAAAdcEHnsvYl/7dqPoeVO7JGc9WNwbg2d+4vPIOHPermNOvsrtK3KvvtssXZt37stfbJ3kqoVi60Qquec/SbsfNI/xCtR178toRAj3jDY8qp0pAtKXUOCDLFOtj8qCQEgEvscjodq3anuB2NqF8F1LuPfnP0JG07lYChwZZ1ol3Rg8Uxwe2G4UXdYicOE+Wlik3cvGZUjthWTTQQDCPR3tiFqAgC0B7qY9X9uHm3ZbUvgBBEBgHQLkr92wOlqJ7O3iWsKdG9q5Chfh825FKkNnbKrR6IrL9wZhCPfRwqKzqtjEuE43zFxcCPfMNTkqnB0C0/mMO2iDw+DsND1qCgJhE6BNMqo4lrTyun+6F+6SCi+2Tq7NO8kAL33+if+63Shem3fn3Qp5ZsxVC9fm3coChyTczcmXKMlO4zDs5kP6ySUA4Z7ctkPJQcCJANy0O9HBbyAAAv4ICH+yLk3UK6Uwj+BeuJ93K2Qs5zvOuTrnQpwLfV5yfn2rtscLow2HJNxHC+vavBM1MgZv/toHd6eWAIR7apsWFcsyAf79QnzdI8s9AXUHgTAIGIM3oS+dz4BqVe/Ki+6Fe2PwXG5fFVsn0ldaSf5KFvTb3j0J/dvePS8J1/ord7qHJ9xHC0scmYXRPYx+m440IdzT0Y6oBQj8hwDctKMrgAAIhE2gbFzmqgU3xmkujl2G3Qt3uwTpoGeuWngavlI0viFe2pfPtb6k6el2CoQq3Kkk+CRT2N04oelDuCe04VBsENAQ+B6PdhqHwqSUr+3jZauGES6BAAj4IzCdz8QkE/judqGM/Qj3/vyHm9V3myVS26OFxc3q0t73p+ErGeP57hp+O4VDFe7m5EuUBO6//PXT1N4N4Z7apkXFskYAbtqz1uKoLwhshMCn1RfKkhuzSdT6D3gW7mSrFsXbbZYk1+wkzXPVglROytSNg/ZQhTu5lym1TjfSvsg05gQg3GPeQCgeCKwmMJ3PSq1TWpNuuvXV9yAGCIAACHgiQP5kJFksSWHPf5KGlnazrEyQC3eta3maJGMu3MVWn3xt31P74KaUE4BwT3kDo3qpJwA37alvYlQQBGJFgF7urVTS3iJ4Fu58C7vQ6OX2FS9DUoQ7PYFstt3pA1vEDbt3NtsiIncI9zi0AsoAAh4JwE27R3C4DQRAwCsBz8K93L5y44XGs3AX3mD68x9+OJVvxCcBGpnFvT//2W2WVrqp4U8X3Cmk1yYK5r6L9tLbpkAH4R4MWX+pQLj744e7QWBDBH4nf/TZwly1gPl0Q+2AbEEgcwQ8CHehX4X4W6liPQt3Ln+FU0WRI51DjV64i4+hSt4qeTm14ThY3OkkA4eGhSYOox3CPQ6tgDKAwHoE4KZ9PV6IDQIgEBwBcuK+UoILVdoZmySj3ZifAxHu/NtM5N6RiqFa3LlXGW6k1wpr94dTue1/pbMaykvs+TloHgfXaOulNJ3PxAe2uGqHhWg9iKHFhnAPDS0SBoEQCEznM/76smxcTuezEPJBkiAAAiCgJ0Bbn93se2kMnrdqe0L/FVsnbs6zuhfu/fmPYXWehq9qSchozb/BxN1BSidftfFJSUsB98J9tLAag2eSv+X2lRsC4gGjbFzqGyDkq9P5jL/OpcJDuIcM3m3yEO5uSSEeCGycANy0b7wJUAAQ2CyBT6v/2Hupmw918+Gx9/Jp9TdSHmGOPTLOJEUr/cnVsHROVIrJ/3Qp3DtjkzSl+ikobuomizs3w0tan8eXND0vmwivJdxHC8uwOvT0ojqplNKnej32XqJv3O/xyE61Q7hH3xzaHCHctVhwEQRiR4BcsOWqhYPmMT6qF7sWQoFAIDQCv5M//qqNBKsIXLQrv5O/0DLXJEyFsbMfSydEJZUsSVXpT5fCfbSwSA3nqgVS56OF1Rmb/Cfa0sP3wxRbJ5Rvf/7D49N1u8C6wl0USex3F1+cpSKpWdAjRMRtulgs+CZMqY+JP7HHXTMYIr8E4R45cmQIAmsSgJv2NYEhOgikigDtKddqKboY5ZeS6eSidt82P4q6VdtbacCWxKt74U4aV0C4Nu8Mq8M35+SqBenjqVygHxlnYqcNSepcteDmzYAH4T5aWP35Dzms3KrtaR9m6LOpEX996Xfyxz8GQp1KCkC4x2FmgXCPQyugDCBgS+DT6tMhoXxt/334YRsVP4AACKSOAHf5Kqko9c8odRXpPPLZIvQ3t3bvNkvSr5JG1/7pXrhLlnIVSK5akGzbt717bTRxcau256bA3oS7qCzfrqOegqVHkcg2QX2PR/T+xIGM+CnKDpa6oRxYhSDcA0OJhEAgcAJ8zS61TqN/cxp4jZAgCICAewLvw4+VWkqKENmzPRnd+Z4TfhDzyDiz20ij1et00b1wV3fFcBp2Vm0SxzyyCGut4FQwCvgR7tJxVU6JKh6luV2F4HAFwt394A0vJoR7eGyRMgh4JwA37d7Z4U4QSAUBO5d8Drrq/xuY87X9yDxNlY1LURixYcbZlkyqd2WA9KvLPTZiPz3fAyN2vDjYzp+Gr9w1ZK5aKLZOXGY3Wlg+hbv0vCHeS5iTL6pClDYabXfK1/b5qSqKA+Eeh6kFwj0OrYAygMA/BN6HH7Q9ZqdxGNk7038KgT9AAAQ2SoC+c0SySehy2stud5QwMnXFHy2ElhUnL13are0U/LrCndIxrI74R1ecA+bkS8Rf982Af+EutrzT3vqt2h6FI3Ymw3uXCB80j38nf/RGhUeIrGttdOTFPXMI97i3EMqXKQJw056p5kZlQcCBwE7jkGsmEZYe47Xqaqdx6JBssD+RT3dRvK3anrSn3Fk6a3/1LNy1qYVxMRDhLrS7tG/nol0JtoFWpsb7WL62T9Jc27Xo15XJIkJ4BCDcw2OLlEFgPQLcga54U7ne/YgNAiCQFgLa3e3aT2lqvW5HudOdXg9KPhk9K+bsCHeh3WmHTK5a2KBwv2hX+CYrCPfYziUQ7rFtGhQsWwT4hkK4ac9W26O2IKAQ4AfTySaq3UTBpw6KedOtK0kGf0Hrp1LrIHItEZ8d4d4Zm7RDhtqu1DrlAjr4Zvs3xZ3G4WPvRc0Rwv1fTjH6C8I9Ro2BomSTwHQ+ozNeuWrhpltX59BskkGtQSCzBMjZIum5XLUg7ZMRcLQCKwK3JNyHYN184CKee0pZS7KLyBkR7k/DV7K1HzSPP60+bY6Kg+1G26+wVSYOMxKEexxaAWXILgG4ac9u26PmIGBPgOt1Cts90lMEHrBP2+8v/JNw/OMSfDbbbhTdO2mRxH3qhbv0WVnaHjOdz2jjEwfrt8E83Q/h7glbFDdBuEdBGXmAgJYA9xohDvJro+EiCIBApgj8Tv64BKewHQSKwAMhuRT8Ho/IMLzTOPwej3ipJD+25fbVug5bRgsr3cJd8kSpbn/irzLUXzntUMMQ7qHi9ZM4hLsfergXBDwSkL4vjfePHjniNhBIIwGtZsrX9u3qSkqaC3ftvhq7FFxe555qD5rHdm8A+Ab9rdrebe9esqk7/5lW4d4Zm+Q0M1ctOOyH4ecWyB7vso2CiqbthFiqgsLrJx0Idz/0cC8IeCHAF798bT+M9dVLsXAPCIBAPAhoXco4bFvXbogP3LHMWmry0+rTro9ctbDdKLp37p4+4W5OviS3jysVMN935PCMFF6HhXAPj63PlCHcfQLE7SCwBoHpfMZtUWXj0s5ktUaiiAoCIJAuAnwTHRnR1xXuK6Whe2bS9yXoC1ArU3jsvXBnkUK+r9w8kybh3hmbkmQvtU5d7mKSHARLu5JWwvcZAcLdJ8DwbodwD48tUgaBfwjwWThXLWxw8+I/xcIfIAACMSMQK+EunZhc9w3hdD6rmw9cvm/V9s67FXPyZbdhJh3CvTF45htjctVCqXXqgR69TsnX9t0/Mvnv0RDu/hmGlAKEe0hgkSwI/EOAW54ctjb+cw/+AAEQyCSB+Aj37/GINLefiUuV77lqodg6aQyeVQN8ooV7Z2yedyvk51G8MPEg2XnH5+9pA3yRwrNQwxDuKpOYXIFwj0lDoBipJSC5aZe+TpfaaqNiIAACXgnERLgbgzdS7YHs65vOZ4+9F/Uobbl9xRV8EoW70OvbjSJtbRKBi3YlkC0u3E1+IG2xsm9CuK9EtKkIEO6bIo98M0GAu06L+EVnJviikiCQRgJxEO7cyhv4d1g/rT53ekhi98g4u+3d3/buxRXPnuDtNuEEdV3sgdltlp6Gr+X2larX7T5H6qe3Sm8/XG6U95wjhLtndGHfCOEeNmGkn10CfPWFm/bs9gPUHATWJMCnDhK1kR1OlV4ShrevejqfGYM3/t1oqqwInHcrnbEZlNoOJB1z8iU5Yudl3mkc3nTrgZjYtV2Gu8nP1/bDy2ixWEC4a5sgDhch3OPQCihD2gjwLwvmqoXA7VVp44X6gAAIMAIbFO5RSkOqsVDwF+0K7czhaljshj/vVm5794bVUffEB6LI7RLpjM2n4eu1eXdknKmWdVHOg+Zx3XwIVUZzVvxRJ7zHKgh3Yh63AIR73FoE5Uk8AbhpT3wTogIgsFECWs20rsV9XQcmi8Ui4s0YWsbf49Fj76VsXNqJ+Fy1sFXbK7ZOjoyza/NOqHn/gr4zNg2rIzT6ebdSbJ3sNkvS8wP/86B5fNOtvw8/NuLSlz/ahWQY0nbCyI7GavsGLgoCEO7oCSAQJAG+MbTUOt3InB5kfZAWCIBA5AS0msnhy6lcUFJ4XeHOjz/G5Az993hkDN5uunVyiUi1cwgIWV9snaz85yzNpSx2Godl47JuPnxa/ThM7PzocBhrjbYTQrhHPhloMoRw10DBJRDwQABu2j1Awy0gAAIqgd/Jn6QaxZ9qTHFFG3ktccmPisZWnH2PR59Wv24+XLQrpdap6p1Gy8HbxVLrtNQ6rZsPxuAtJkpdbX3pDUmwe3Ug3FXgMbkC4R6ThkAxkk2AGz92GofBTqDJRoPSgwAIrE9AKze1Wlyr8h3M81JZ+IGcJHq++p38fVr9T6v/2Hupmw9180FY6IXydv6vsKCLu96HHyIdiU/M//T5eSyH2kG4O8DZ7E8Q7pvlj9wTT0DywBCNh93EU0MFQAAEHAloN4dod79oBZbDhnieLX9PCIsDJ5OsMH9hEtQ3ubX9KrZvY5LVXj5LC+HuEyBuzzQBuGnPdPOj8iAQGgF+Woas79pjiNqYbgQWP0Z/0DzWmvNDqx8SDpjAY++F+slFu+I/dQh3/wxDSgHCPSSwSDb9BPhE6edj4OknhRqCAAisSeB9+EE6jAI7jUM1Ge1W75W79fj0FYjOUwuGKxETCPZJDMI94uZznx2Eu3tWiAkC/yHAd4XCTTu6BQiAQBgEtIpc2gjB9Tfp+4PmsXN5wthZ4Zwjfo2GAH8J7HPvE4R7NE3mIRcIdw/QcEumCXxafXIwnK/tvw8/Mo0DlQcBEAiHAPfVTaI8Vy1ctCviGCXX3zyCw0d5pLOMmL7CabpNpsrtSn5WqOl8JroZ/+/v5G+TdUPe/0cAwh0dAQTWIMC3k4bhOneNoiAqCIBAqglM5zOt0Z1rdDXsYG7n5ljs7kt131nwhzo3Bx7STSNltYNwT1mDojphEeBfAs9VC5gKwwKNdEEABP5LgDvqVjW6eiVf27fb3c5d1sLo8F/Aaf7/GH5RK824I6wbhHuEsJFVYgnwNc/nxsHEMkDBQQAENkCAnzhUlTq/4uCFne+6wVHUDbTihrLkGzvhOGhDjRB8thDuwTNFimkiMJ3P+DtHuGlPU+OiLiCQCALc2zpX6jxsZ1CQZjCH7e+JQIFCrkuAvyt2eCGzbrKIv0ECEO4bhI+s406Ar5f52r7kzyHupUf5QAAEUkTAGLyVjUsu1kW41Dq1k+MQbSlqf+9Vkb4SaNdbvGeAO6MlAOEeLW/klhwC3M8aDnIlp91QUhBIOYHv8Ug4+rDbzi7qz/fHHzSP4Q8k5d1iVfW4ZwXtl7xWJYDf40IAwj0uLYFyxIeAZJ+46dbxTcH4tA5KAgIgsJIAP5iIDX4rcWUkAj+shV6R3EaHcE9u26HkoRDgp3n8OMENpXBIFARAAARWEeC2Vfi/WkUrW79L72GcX9pkC01yagvhnpy2QknDJ8B9L5Rap3i5HD5y5AACIBAYAf620MHJTGD5IaEEEpA+wvVp9RNYiUwXGcI9082PyhMBfooLbtoJCwIgAAJJISAdpocxNSkNF3054WsoeuYB5gjhHiBMJJVUAtxTcr62DwtEUhsS5QaBrBLge/zgsTurvWC9evM3zPDuvx67jcaGcN8ofmS+aQLT+YzvB8V5nU03CPIHARBYmwA/inrRruAw/doEs3oDN1rhe7pJ6QUQ7klpKZQzeAL8zXKuWoCb9uARI0UQAIGQCfAvxGESCxl2CpP/Ho92GofimwB2n/FKYbWTXCUI9yS3Hsrug8Bj7yVf2xezFdy0+wCJW0EABDZDQDpl+D782Ew5kGvCCaAjJasBIdyT1V4obQAEuOOFXLWAN8sBMEUSIAAC0RKAoTRa3unPDa9uktLGEO5JaSmUMxgCn1afXgvCTXswTJEKCIBAtASwNTla3lnJDYclEtHSEO6JaCYUMhgC/BA9vgEeDFOkAgIgEC0BPo/BGUi07NOfG9wTxb+NIdzj30YoYQAEfid/pdap2NGeqxZuuvUAEkUSIAACIBAhAbjfjhB2drPibhvytX18ECBuXQHCPW4tgvIET4C/Voab9uD5IkUQAIHwCUgnCPG5ifCRZzeH6XxGpi58gjdu/QDCPW4tgvIETIC7aYef2oDhIjkQAIFICHyPR/CCFQlpZLIkwFfPuvmw/AGhjRKAcN8ofmQeJgH+vg9u2sMkjbRBAARCJGAM3ki14yNxIYJG0goBflwVfU/Bs5kLEO6b4Y5cwybAlzp8VCJs2kgfBEAgJALc6onDOSFBRrIOBKS3Pb+TP4fI+CkCAhDuEUBGFpESgJv2SHEjMxAAgXAISFOZMXgLJx+kCgIrCPxO/g6ax8K7A46rroAV/s8Q7uEzRg4REuAfJcGRmgjBIysQAIEgCUAqBUkTafkmAI9GvhEGlgCEe2AokdDGCXD3xnDTvvHmQAFAAAS8EYAvbW/ccFfYBPgii28IhE3bLn0IdzsyuJ4kAtx3Fdy0J6nlUFYQAIF/CfDjgBftynQ++/d3/AUCmyTAz4/BUdtGWgLCfSPYkWmQBLh1Kl/bfx9+BJk60gIBEACBqAhctCv0nTg44IuKOvJZjwDfknrQPMYXmtbD5zs2hLtvhEhgowS4ywU8/W+0KZA5CICAdwL8tSHO53jniDsjIYDPgUWCWZ8JhLueC67GnwA/vJWrFmCdin+ToYQgAAJaAvyjE3Bfq0WEizEkwF8QPfZeYljCVBYJwj2VzZr+SvFtdljn0t/eqCEIpJfA+/CDvq900DzGpvb0NnUKa/bYe6HNXTiuGk0DQ7hHwxm5BEZAckqFb7kFRhYJgQAIRE4Auidy5MgwYAJ48gwY6KrkINxXEcLvcSLAz8RgG2icWgZlAQEQWJsAdhqsjQw3xJIA9npF2SwQ7lHSRl6+CHDTFE6y+0KJm0EABDZKAGf7NoofmQdPAKerg2dqkyKEuw0YXI4TAenT3zfdOraBxql9UBYQAIE1CHyPR3xTO7zprcEOUeNNgL9EgseIkNoKwj0ksEg2MAJw0x4YSiQEAiCwaQL8YD082G66NZB/8ATwBbHgmf6bIoT7vzzwV8wI8A8sl1qnv5O/mBUQxQEBEAABtwT4hHbTrbu9DfFAIFEEpHdKWLiDbT0I92B5IrXACMBNe2AokRAIgMCmCUj7/YzB26ZLhPxBIEQCfAXP1/axHyxA1hDuAcJEUoER4O6ldhqHn1Y/sKSREAiAAAhESwAiJlreyC0WBPCwGlIzQLiHBBbJeiQAN+0eweE2EACBWBLAtoFYNgsKFRGBm26dvtCE7WGBQIdwDwQjEgmGAPcFm6sW8AnlYLAiFRAAgQ0R+J38kWrB1+I21AiZyJa6GQLxIRBSz4NwDwkskl0S+LT6n1b/sfdSNx/q5kPZuCy1TsW/g+axwxijaKXW6UW7Im43Bm+fVh8b5pZ8EQIBEIicQLDT2vvwA9Na5G2YqgwdVlL8tCkCIfUwCPeQwGY02e/x6H34Qeo87NGSr+2Tpv+0+ji6ntFuh2qDQJgEPq2+MXjDtBYmY6Ttl4BYbYutk2vzzsO/7UYxVy1sN4oe7nV5i88SuswlkGg+aRRbJ6KyfhvV5n4IdxswuOyOwPd4ZAzeLtoVZ9s5V/C7zVKxdSL+HRlnDsOMohVbJ2Ig8XTswqXW6U23/j78gI5314aIBQIg8A+B7/HosffieVort69cTmtbtT27eYxfFxaKuvnwPvzAt+f+aSr88V8CosNcm3ejheXhn9CaxdaJh3td3uKzhC5zCSSaTxrX5p2o7H8bJ+D/h3APGGgWkhOrWtm4pI//8TVGhLcbxWLr5LxbuTbvnoavhtUxJ1+BjKjO2DSsTmPwfG3eldtXxdaJw+K30zi8aFeMwRtEfBZ6JuoIAp4JiGmt1Dp1Oa0ZVsewOv35T0jTmjqp0hWa1iDiPTd3+m4U3QPCPZDxCOGevgGS0Rq9Dz8u2pWdxiGtHzwgZHpj8GxYnUBGzlqJ9Oc/htW57d2X21e7zRIvGIUPmsc33To2x2e0+6LaIKAjIKY1O7Eeh2lNWCgcprW6+YBpTde22bomVrpr864zNsvtq1y1sNJY1hg8b9X2yu2r/vzHp1R1s15TCd1E3mwcotGf/5x3K1u1vdvevXORzMlXrlo4Ms46YxMW92yNvRjW1nlhy1ULnbHp3KGj/7U//7nt3ZNklwI7jUMo+Bj2NBQJBCIjIKY1aWagP3ebJUxrkbUFMgqEgOi9QriL8Hm34rz4Cnm6VdsbLSySqs63+PmVSugnkWju5TTEK/3dZsk5axLrhtWhcCAtqyaCrTIqE1z5XwK/k7+bbl01RO02S2JqoK7p3Js39athdcQ0YVidp+Hrebei7pLfaRw+9l7wuhk9HgQyQuB7PLpoV9Rprdg6ue3dd8YmX7A3NXc55EvT2tPw1W5aO2geG4M3TGsZ6dJUTS6L6WylQ18SFuJctVBuX0G4S6D4PCBeX6x8g8GZkzqi1gk2AOEeLM80pPY+/Ci1TsUsQP89Ms4ag2f+6o26ptTjY/InrXB8605nbN727lUFf9Gu4F1zGvou6gACNgSMwZvdtMb3qfMFOyZTGS+G3bSmGibytf2LdgVne2y6Qwovc+FOL5z58sc70mhhSXEi6Pm8hFJh4vYnp9EZm6LkDm8wpDikjkLqZxDuIYFNZLLG4E3awr7dKN727rlepwFGXZOuxCqgXeGohJ2xKTau0ZNJrlo0oG3XAAAgAElEQVQotU4/rX4iWw6FBgEQsCGgTmu7zdJt757rdZoZ+IJNF+MTWDmtldtX0mH9i3YF05pN10jVZS6LJWu6tgNzCzEs7hIiaR6QWEmRRwvrvFsR/IVYInUUUg+DcA8JbMKSVde2cvvK4WF9tLCoa6qdOA5XnFc4KmFj8CyGKCl4yPeE9V0UFwRsCGinNefN69KCTRNFTAJuprX+/KcxeJYOs5aNS1jfbbpJSi5z4T5aWKIDiP3rau+VLMQQ7hIiaR4gtWMniqR98BQ/pL4F4R4S2MQk+z0e8TfI4oy51sQu9WzqmtL1mPzpZoWjohpW58g4I+2eqxYu2hVsEk1MJ0ZBQeBfAp9Wn39ZYqu2d23euZnWpAWbpoiYBNad1iSrxE23jmnt356Snr8k4d4YPIsrjcGz2nslCzGEu4RImgec32A8DV8FavI8Q+oopO4F4R4S2AQkO53Pbrp1rlavzTvt62OpT4s/qWtqf934xbVWOFFac/LF17l8bf+x95KAhkQRQQAE/ktgOp9dtP/z2jpXLQjJ7n5akxbsjc9jUgE8TGuG1ZGmtffhx39p4f/TQ0AS7v35j7hyZJxJvWi0sCQLMYS7hEidBxzeYNDpVZpnSB2F1L0g3EMCG/dkP60+385+ZJy5MUfxzk1dk1+MT9jDCicKb1gd/pa51DrFK+a492aUDwT+j8D78IN7jBEOqtealNQFe63bw47sZ1rjh/LLxiVM7ykbNJJwHy0seo1MglL0T9VCDOEujVx1HqA3GE/DVx5Z+4BE6iikPgbhHhLYWCdbNx/I0L7dKNpt2+K9Uw1T11R/isMVzyucKPxt757OeOVr+7BRxbpDo3AgsFjw94e7zZK3aU1dsOMwm1EZfE5r1+Ydn9ZwaDVN40YV7lqBPlpYqoUYwp2GmAio84BWoI8WFgl6viWJ1FFIHQzCPSSwMU12Op+VjUtS7efdivQsLnVfhz+pazrE2eBPPle40cKSds5g20xM+zSKlXkC0/mMH9Tx/NX3aOSLn1kxkGmNv1E0Bm+Z7z4pAaAKd+2WGDsBqkpVPx1Ve6+2hNqY2ovX5l2xdSI+ZqyNQBcNq3PerYjI5fYVl9QUxzmgpaF9gyFiSoeASR2F1Lcg3EMCG8dkp/MZHdjaqu15s0hRd6euSVdiFfC/wonqUDXFidU4tivKBAIZJhDstKZdsOMzswU1rdHZxFy1cNOtZ7j7pKfqWllMxnXaCqu1EEfzyKotocvBRW5wctVCsXVid1d//iOGsMiL/rvbLK1lo9TOA/QGg54E7A6tkmwIqXtBuIcENnbJ8uVtt1miYWw3AFZep665MuZGIgS1wo0WlmF16P3yRbsSu6ZFgUAgqwSkaW2ttVk7L2kXbG3MjVwMcFprDJ4xraVp3GhlMeld+niQ6OGShTjmwr0//+GvieyEuxSNVLsI7DZL7ses3TwghgwlJX3EitIndRRSB4NwDwlsvJINfHlLjR93GmnOgc7YxCIXrz6N0mSeAJ/WPJxD1Q55uwVbGzn6iwEK99HC4tNa3XzIfIdKNgCtcB8tLP7xIDsLcZyFe2dsctXuYHGnrSwCRbF1wg9k56oFspSvHLl284D0BoOz5WlCuCd7LMWk9OQfbd0XRrwvSmHqmtJ1uz/785/b3r0YDzSu7L5fKD5FJvaoaf+7cgQGu8JJixw2hsakY6MYWSZA+9rL7Su7aWfd63YL9sp0+vMferZ3v8lefABOTHHOX4YSBcC0luUO71x3O+FOK3VnbJKFWHKNElvhzr1EiAraCXd6t5CrFrjOIaltd6N2aNvNA5TLtXlHYXqbQUkRc+cm8/wrLO6e0SXmxsfei+jxvDdTD/McoK7pJoXO2JSefWkQbtX2tCsWRdAGVi6Nga9wknb/Ho8S0wNQUBBIHQFyjUWvrd1MRCvj2C3YK2/ku8ZXzk4iNXPyRVo/Vy24OXQU6rSWr+3D9W1yB4pYKNW+x63sdhZiD8LdsDri38qhQRHsSkgReOBp+GqnGbRbZfgA5IpCHMbdbZaKrROtS3ueKYUd5gFiSDmqG49JHYXUnSDcQwIbl2R/J3/CsfFWbc//BlDq1mttleG2KK0KV8tGz7La+LlqQZ2eeNnExnRxr5vlULrX4U86nnLQPI5LG6McIJAxAt/jkRjd241isNOaw4LtMC3QgT9RqpWzk0hK5EVTnJuZKgzhzl3alVqnGetK6amuQ98TW03oKVG1ELsX7v35T7l9RUmJTI+MM66V7UaKQwnVW0j7irtWGs5pO812o6imtu4Vh3mACiYgaA0HFCek7gXhHhLYuCRLb5PVV2PrdmUpPnVN6br6Jz2Y0gi8Nu+k7WjSVCIthOJG/t+VS2NIK5zYwyNKgl2hcenlKEfGCNC05kbsqjOSwxWHBdvuLml+c2NW4IYPmtbc1CW8aY0mZOwDTOhgEh1JuzJK66lWZLvp+fxQBPVbCqzcv+pQQnVwkcDYqu09DV+p59vteKFikFldvBBQzeFqXuoVBxr0BkPkeNu7V2+nwofUlyDcQwIbi2Q/rb7oW9SV1R7m+Qp1zZUp8BdevJfTfrtctSA9JfO1sNy+ordyFFg5Gmmcu1kOV1aBR+jPf0SN8rX96XwWi5ZGIUAgMwSMwZuY1qSnfT5IPYcdFmw1TekryyQdtOKJ3659o+hmpgp1WhMWxJ3GYWa6UqoqKrqftu+R73ax/5t3RQqv7PnSm/Ot2p56+tPZPuhQQioGBYTAoEPn1PO1wp2L6WvzTtoZv90oOheMMqWAMw2y7ueqBe0bP1JHIfUwCPeQwMYiWTqTulLmUn91H6Cu6XwLH1GSCyo+m+SqBZ6OGDZinLtZz/i9Ikzj3NvtaoL8ChkwYJ2KRUdHIbJEQJjb1f11fIR6Djsv2DxZMlGTXqeAVjzxe/nCT3e5malCndZoSse0lsTxJDqSXd+j7sptZ7xPruz5fLMK6Wm+z0o1wPH0RwvLuYRS5M7Y5LqFer5WuPNfpW08NL7Wes53pkECwM4kSkMppI4E4R4S2M0nO53PRJcN0OUCH1rUNflFNdyf/1ybd9fmXbl9pY4cGlSScLe7rqZvd4VGspvl0C4Rh+vC6I6d7pvv6ChBlgj8Tv7E5KBOJg6j1f1Pzgs2T0fEFIXZbZb4S0I78SRup5hbtT2u4N3MVKFOa2RSLRuXWepTKamr6Ip2fY9kt92GFueez61s0uvx0cKixHPVgnYfjuj5ziXkg0sNU89fKdxFLtr/ure7O9OAcE/JmIlhNeiFsvvOqo4WhysuhbtDCvx9MT8nzq/vNkuNwfORcSaOhNtNOmouNM7dLIfq7Suv0OoLPwwx7PwoUloJkI8sB32wcvA6RHBesPmNJNzPuxVhniCtYCee+KH5XLXwNHylRDboVYZXihRYWvtPiuvlIIu57NYeplx5OJXW01y1oJoCyWeD8wEPhxLyTqgN8wJwtSAi819z1cJWbe/avDOsTmPwzHfqqo8c2rxW0uDDFltlUjymNlC1m25djBO7runzun/hTi/vctUCf39Hj7O0EPLAbrPkZs2mkRyScKf034cfG2hdZAkCmSRQNi5XvpH3M7OtJdyLrROaXmg+dNAudDwmVy2Il+xcAVBSDuWnacdNZId07H4iBfZp9TPZvxJcaQdZLC2pfAsK9QTnns+793ajKH1chb84sts9su5WGSqYCFDPd2Nx56OD3iMJPvwnKQv+pwMNvvvX7qNOhCuk/oStMiGB3XyyYieo+mzKe6efMHVNb4nwk6nSdlUyZnO9zsNbtT3t1MNLQuPc5UDl97oMiyJF41umbFyWWqf076Zb33wPQwlAIHICB81jUr0ux+la0RwWbCkdydJG86GDcCdTBXmxjJtwJ9PsY+8l8rb9J8O6+UDTnQj88zP+UAiI9Uj7tkd0PNr8rY3j3PN59+ZrsRp2kBwOJZQGl/onLeha4c7FtPpKgd4jOYxNKUcHGly62B32JVxKKwVzAcI9GI48lel89j784PPORbvy2HuJ+JM9O41D7VstqYN6/pO6pocUJAOAtJmHL2bCuqaeXnd4rBfloXEennAX82AEGpq8A9EsCXfLfMQhHD2B7/Hosfdy0a6QuqqbD+/Dj7D9LPlZ+93MVA4LtvPtNB/aiQMyZvNdMXyuczNTRTCtCcLR2CPs+u10PhOfH6EZL1ct2EXGdUHAbmiQqC23r8S+Ee2OEeeez7u3anHnBniHwyd2JXQeWdKCrhXuZM7X/soLr31oUQvgQIMY0vOAakakHEPqnBDuQYKdzmd180GdcWj2KbVOI3sF6W2QiM8rSMYktVtzP8TaXx0uSqpd3TBHi5lw4EpJSU+66mihmHwvqZvlsDM2XY5nnoUoZwQaWlgZqRflqoUIMg1yYCCtFBH4tPrkRp33SRHO1/br5kN48t3PtMYHr13YYcG2u0Vcp6VaK9z5+3qubGiu42reIaO1hPvT8NX9oSDKVBDerHCnfZ68g6VoDIVSFbuhQevm0/CVeqm63dS55/NVm3dg6jZuAnYldHMv9XytNB8tLNquoz6WUK21Y1Obux0NOoB33q1QkVTxQDmG0tKLBYR7YGB/J3+qwOLzDoWjeQvpweLeGZui96+0Z3sW7nz8O78QMCdfqjSnwWm3t4wGIQ2qlcKdPjzOXVxROg6BaCzu2jUMwj2wcYuE1iFAZ0NpNtMGDprHIR3aFtmpK6XDOKWvxqg2AvUuuwVbjSldoaVaKw5IoO82S9wsQtcDF+5r1ZrXRRDeoHB/H35oO9U6/TSLce2Ghlg0hZzl1nfe6CuPY9KN2hMm4hHRsDrqks1zsSshj2MXpgXdTrjzHbbSos9lg/STXXZ28wDlIp58yPoupUOzQUgdEcI9GLDaV3va2UdcjEC7r7vH/Wn4SnvgpNVF6pTiT+qa2l+1F+kWAcHDgztPwXnxpnG+cqDSCif2q/FlVVsLuihqEeoKR66BpL4E4R7MuEUq6xComw9SP3T4c6dxGIbdfd097o3BM01rDrtvaVDbLdgUwS7gMDXRXEQb/2hrAZVNTD7F1onzrEhJrZzWDKtDiRdbJy6ntY3vcf8ej+xeWa/TVbMYVwxGaVnkFmLRdYWKlb6pslK4c5O29GjK3yYJX0l2Y0RbQrvI0nXq+XbCnT9abNX2xLsmsYOApim11lIu9KfdPCDGFG2jl3Q83U6zQUgdEcI9GLAO746p00iBsPfMkKWWOpNDgN6mOVvBeQrUNflFh7Bka3d4h9sZm4bVkSYgkTJlKs0dar40zleucKOFZU6+6KF8q7anvkZ0SD88rzIO1k0I92DGLVJxTUA9aCFNaOqfYfTStbzK8OnCWRDTALdbsCmCXYDnJc1dNBepiNQrzk8XlJSbaa0zNskX3naj6GZao434YS9P2n73afXtVDv2uGuJ8YuiL0l9T1WWtBBrj5Y5dD/qeyKj3Wbp2rw771bo+dBOUtOQ0ZaQfnUO8NztCkmVVYfVullr5wEaHeQEj54WpLd5NBvwBgowDOEeAEw7s2i+tl9qndrtnwn7y9JUKml8qsODzlhIbhnVmPwKdU1+0S5MPV6MHwfVzh8h1MWJ3DIEuFVGlLk//3Gf+Ghh0RwRxpaA6XwmBIrdBBSGJApgJCCJ9BIQW+/UDnnQPC61Tu30VuDf4KSnWWcZuu5wpolLu2DTrw4Bmg9VmwLXHCpA6YqdKBFZU1Lq3KgtW3/+w00S7teC6Dvyyvc50RcpWTmKjiQJd/HkRhbi0cKilyrShlg3PZ93cqnfCu/pG9wqI6pGvV0tnqStteOFLmppkFLi1dS+wSBQIXUhCPcAwGqXtIt2hd4U2xkSAl/VeGXcfDl13WmduvVae9xpE7kYS86mL3q1pz6+859y1QIfPLxgIrzuCifuIjmeqxacyykmxDC+nPo+/ND2KD4TQbjzro5w2ATICsA7Yb62T3bZ6f9r79td6zqi7v8k9catBalsXKQQpBIuUhhUBFwYQ9y4iBC4kHFxwYUSjFERuK5EEFGV2wRhBCospO4SCOqUNOruj++3P9a3s2fPnMfMed27QIi558zsmbNmP9a8zrn/99XJvr4r6eLTE3W+nNpiAQ0OxA3YuJtIIFSHxP30doG9MSahZysfH+0W3CqjmwrCkZ6awZ6Hnr+c+vX2ps6SdddKPnX5YnGauGO+DDPEohWYotIbqGpq/sfrz1jG0fZe54RY2EKtpek0AnpIDHTBi/srHcSlRvkek85WmQ7RgHWYAQ+mGvWoGN6gI6Uicc8F1l1BDsOVG/m6pl+YtXU5rl5IrflVI63uUE190U3rsKFN3aRRVmxG7j4+2v14/Vl2zuggVzl6hp3XnJpC7VhJlNdFa9cW5il7ViH9vg4NV9eak2sVLL9eCLi8Kpx3cAecIPelIJHGmI8/wDbNkRXX9SFzmAgDdpjHvQJ/GBJ3N79c1L6ujqcq4tZiHAsUJOzZUn1n5Px197c73tO+DmlTlj8NAgKUJu6IvMYKEOP00ncjzT+9Xbw9//Bm8e7N4t3s8pORH1P4sIWxnOH1i/ur+fJU/tKrbbL3dXb5SZr38fqzG8TDKvSVEA0XtNgKBryB6aNSP0ncc5F0/Y7L59zV5C42WuCRMKgIaa45s9VCs6GaWt3DNDaBwf/GEiiL4BTL2fUHmNKxH58/fHj4FIsqwLx1AqOs2FPr6yTurXFmwaYIYJJba+DDw6ehHOxj0TlfneyHOXOuYBIkXBNDcJWzOi3cWhiw4ZfSCfjDcRJ3eUMu5j7C1w9gQjGcdcrprERZV1u05ph0QhRvrVYrgQvEHR1qZohFjUUT9Baa1pqftgt917RQ3xpbOkQDH7EKvUq4ggFv0JFmkrjnAutOMrl03KX4Xc9tYKpMT+dAq+ofRQ3tCkLCW/oKZnGMFw5/6lI6AJucTQ+P6gfXVaTTZhORFoIHL/s+GfSUeV5XbUjcc+2W5WsjAKKsNdOl4y7F74II4uCQnnvD/GIj6mz8QBiwTYbYT7iFRrVLdQKsdjKxWjCpUSdzKAQv/JUdyS56XYck6F1sU/u3R9+jf7XKoSATLgKCFYg7YqieVodKwFgwWd5a8yGzMmFaWJl/wAwGDcw/hnOgN6tlCDW8gdtT+RdJ3LMwxD5y7V9i59/dCYauv7uJUCory+btSK5J17QWqGY6PwajBqLwp5FzerswZR8cPokt8pqyTT/AFBaXJTB4N5yFReAsTkdc4i5jgxArEvcsu2XhJgjg/VRaD2OjVnddseDClDQca4mPZjsX91cX91dgwHgTnGvUlRdNwK7Mjwzwh2Mm7uLW4FeBFZhHF4d2YrrmEve9+Y//3P/rOsOYHF4XBMQ8Qdyll2M7yhDIkL+15sMEKhOmhZX5B8xg0MD8o97IrpsnKxg4WQ5v0JFykrhnAYv4oUNajFQ1ypzVrP8WxoDh8dEuzlzXnLfWqmnSUE1zvfjPmtvaTL1wTO2mpiANjylb3rHW/PX25r8w5/4yseqb2XfYHKy1S9IxHcttBMsTgQABo5migVBOk71RZlO20U8MJ8q6NROw4QdGkijl1vQBPrzR7+Hh0+JuLdGnhrg/PHyKLaauFiVE8ZbZKpOeIRZlljOm+M5oD5ovrgNDhZHYlNsMg4YQJ2AVFsEcn6xggDZ0pJkk7lnAghNrahUjVS5xd7eKZrXJK2z2Tz8+2sUCWaiCNa9ANWvm7zlbqQh3s1rqT1NJRyPAeGC3vIZYpQOYyNLaJemYjrWsm8WIQBwBdxK9EXHvwl5Wq5XZUBHu227hc0zAbiGh0yIF3Rpm2eFeetskI7qmiftPZ+/1sgycIdoWW8eOq+3G3RGshBZXzhDrNxrLjqkeNF+3sFMzyReu0cDr7MJDNagIhikv8AE76kgLSdyzgNWuBy7G3f25Wq0a7avJalZQ2Aww8ll7o9dBQrn7TMCQMmfcpc0myHUxLyWv/J9f/qYDmPQkVAsJEvdAx3mhKwSgdTrhHuNZrVaYCNeZY/tqMlus3W9iMqyR29EBu1HBfjJ359a+mX0X69PMbooVf7/4+ZvZd+8XP4f1krjHQEtcF4sT4l45QyyvXpEism+7B83XLezHXlrXotHA8pQ+ExJK1isYJO4JRR3+lntwMBGldDBDOnRbZR8sDKVFpqagmqEGj+FKwQinXzIjvfbw8GnxD6Ym1ACqggSJe1kbobQYAjgkA92TRCy/JtMoEpvLiAmpcz30vUXcmg7YY/Bjpg0F3Vq4kNjzVpmExyNxr2MCJo+Y25vFuzozxKJX+uNBPWg+Wmi0eoQ/NRrCyPUbeNwGa34PdmT6qNRPzrhnIen6l6bEPbbonNWy/19Yf4BTNmBgcfnB4ZPMqWiopqvEg18sFeGw5rh1sP3qZF/ThY42AIT9DgKEBIl7iBKvdIGAu8EvsW/BJe5l1fWf+3/hxx4ePp1f/oafj2Y76VmxSr+kA3Zl5v4zlHJr8N6hW+t5w4yrtG5gdXPyIhAALZ4vT0WNK21Botuz+YvF3ZceNB8t7N9wmtYINBZ3X2T/uvmIVShQzhU8PtqVz87Iw6J3yiZI3LPwdP3LSIj719sbxDNMpWgq3+jtB6GawvWHt8ZwJT/Cma+mo1v1vqMuphJDjQRfR6IsEwpr5BUiIAiMjbh/vb3BG3i/PfpeNq1pKp/p1hCwx+DEwjbkuzVQNHEmoOl6xNWPW0uYmBtYE/l5yxxOlZ0wof6YK/JGJrnYg+aLyk3xcKoGymCof2ITMthRR5pJ4p4FrOtfwPBC0SBeOtHFjPufywscKfv26HuzbVr7aBkgauWrmYZq1szfc7bMCKc/UBVujEnDG/Z75hWtLZImcc+ElMVrIjAq4j6//A1ubff4B+PW9J7AFp+CFgfVA33J8YSZbu3t+Qe8F+vh4VMTetLw1lSYItncwFpE8hoLkdDQmhb3oPmZLcwxnKZlM9EAO+pI30jcs4B1/cvgxF1/MOXVyb4Jb/LAfy4vMHEln2HCYLGmikM1a+bvOVvrCId1RlBkdy+mu6CRpUzxwtIS/Z/EPY4W75REYDzEXU83xKaEf7/+A8x+62D75dl++JnDtCPKDNhp4fl3c9wa3gW8dbAdDntEadwFjZL6VE+WG1jrFd3cXJm0uAfNz2xhvvnUl5CJBthRR+pI4p4FrOtfhiXu9Tdh/3P/r56jenD45M3iXf04B9Wsbwx95mwR4bCbTfxL+FpGoyv6QyGy19ZkKPVTU3ZJk7iXwpZy0giMgbj/c/+vdmvY3eG23OwGbOrWMgN21y6uhVszMxF13JreY1n8FL7ba+aiG1hNHv40CEho2Dl+/mbxrsUfXorSomzNIpktrFlLkWyZaIgbSZwFMn3X9CeJe1PE/pPf9S9DEXe90TPc3fGfdqsffy4v4KblO9hvFu/qzL6vE3E/vV3gAwriXPbmP7oT7Qq5/03qwU+i68OC9a9Ik/R/Evf66DFnDgKDE3fj1szujtijmRXF+vR9nYi7oexyDtVdgA1h1COl3k7hoxluYMVdJlwEdIBgeiQIuD2Vf5HEPQtD82Ej0ZUEe3OVqchLwfUS5zez75rKnF/+pnfOyOaZ9Jn09SDuH68/Y3AsvbN7/ENNcgDV0XuT5JPduFUkEaoNiXsRYCmkEoGvtzeh+iVmkvSGFhTcm/9YWZGb4evtDba+fHv0fc2xNEQZt/bg8Mneyeu0W1sP4j67/BS6taZBof9T+Og4EndAUT8Bc2NiPAjU775GOUncG8FlM7tRKkbcu/sAk97ZGdu8aJvu/TZxbutg+/HR7tvzD+7+mUkT98Xdl5dn+7IcBiNvQdmBYibDgBw3gRYiQeLuAsWLXSAArdOJWEV6AQr5Yy4xJkSuFxkP/3P/r+vWZpefXLc2aeJ+ert4ebaP46eCf45b05ElfMlBuvty7pK456DHsmuPAIl7Vhe7xD1GqpouOtdsmW5D7MxWTVGSbX75W+g3n81fmFA3ReK+uPvy9vyDPqQlse3VyX7TWfYQ0r/u/samI7x/M8zW4goIEBIxHWshnEWIQBoBaJ1OxOwldB1bB9stiLseAPx09j7dwjp39eve8SChW5sicU+4taZrFCGS+hR+i7XcUGCdK64W1SnIPERgExAgcc/q5d+v/0AMQCJGqlziHstcp1mNzmzVEajzfL29eXWyj3VqPN3O8fO35x9ObxcTIu7z5enLs/2Qr38z++6X81/zYxtw66hHAD4SOWqD1jJBBOoggOEo1G/rYLsRcY9ldmvXp0uLn/mOubVn8xdvzz/gHec7x8+7PmbaTr4+nPrx+nO4bLh1sC1ureZedrcLzMXeTuGjXhJ3QMEEEQgRIHEPMWlwxd0A+s3sO1eE3jKIENh6jrzdmS23YemLv1//4W7lxyOk94y2i0/5pfQXT9FUSTw8fPrqZL/pjs80Svpu8TUQ0355m5uukWki0B0CrvnHXu0SDvW3Drbrj431/G7ZZSuNj+yfcZ9LbK31a+DzHVdaQsKtfTP77qez9925NX1ctcUSisa/Mk3iXgkRM2wyAiTuub0fkqqtg213tkMv/qJUuwP7Zkd1d84a6Pxz/+/v13+4c/DyLPIWqtnlp6F4/Hx5+vb8gzuzLi2UwNZo8g+P3zRR9lMm0BYkOOPetEeYvzUCeiAKDXS3r7jHeB4ePq1Zdc/fNVutVsLgY27tweETcWsfrz8P4tYu7q/Ere2dvA4XDKUvvj36vlO+rvtOnzqIfSFE52+dJnFvDR0LbgICJO65vey6GHc6yry2RdxuC86tSWEX7zCpROTr7c0v57+6D464/vhoFy+UnS9P58tT9yhYenrJvbu4+zJfnn68/vxm8e7l2f7O8XNzxhRt2DrYfnj4dG/+4/zyt/pzfpWPXzNDwcGVfiJJk7jX7AVmy0fA3ePnritqYgelrflKGV22U1IYA+Tr7c37xc813drb8w/i1lwf1eJi6NbMGVPgKZthXp3sj8GtdeRX3ZRoajoAACAASURBVF6IdRyvE4FNQ4DEPbfH3Q0wIa+qH/zSDdLT9u6kV7p48btC4l+d7LsbYXWwQXrn+Dn+0t9KEF4umWMTThCLxO7xDz+dvR8kqhl4S21nwqMhESqYqZo/iUBBBNwNMOHilcu33FkM0za9DaPdIqQRmPnzz+XFL+e/vjrZd2dbYIZIyNy8eKpn8xfr7da6O4WPXnMVCXeZIAIbjgCJe64CuKvDWwfbOlxpAgdfv3Ww3ShE6TNbRn7uM5Qr/+fyYn75m0xc1afyGpOm6d3jH/bmP75f/Pz79R8tli/KPXpUUj4pCTEhcY/CzRsdIKDnC6CN5v2AesoceSr3yWjfWP+zcR08Ykok3ZpBp+tgROJuAOdPIqARIHHXaLRMa2aGiCUnCN8vfv7p7L07X/Xw8Km7Fd5tRA+THG69+Rf/uf/3z+XFn8uL94ufBY3d4x/wp+EK0w8PnyLn7vEPIuGX819FYH7bepOgl2VaHEcOkSFx763vWNFqtfrr7u9QCWUr2k9n7xM7TNKnGDM/Gzdg1yTcWuWEhXZrMunwfvHzFN2aHs6VXf4lcR9Qt1n1+BEgcS/QR//c/+tSczfU4WL96fb+z2wVAIUi/otAzqdMoDNIkLj/F13+6hwB94gqFNJNfDP7LjE3kWMRnT8tK6iHQEcHrkjc68HPXBuKAIl7mY533wvpBjO5WPPA1mq10gvQg5zZKgMQpaxW+lV3jT5lEioSiTsVqn8EEu9PDFV062A7sXUtcw2q/2dnjTEECp7CRxUk7oCCCSIQIkDiHmLS8oqeF3fDGC7WfxWM3oSTXnRu2WgW6xeBdp8ygeYgQeLeb7+xtv9BwHxfDNoYJhK71Y0QfRaIKE8UAXNQITy13PS5SNybIsb8G4UAiXvJ7v7r7m/X4yCwPTx8WpN/t2N4JR+GsjpDoOl4TDb36/+kO511DgVXIPDL+a/pnYG7xz/E5tqLM7yKtvJ2XwiUHY/JGw60x6sZN/t6XNZDBIZEgMS9PPpfb29+OnuvGfw3s+/25j/+cv5rYsenbkfrPRVaCNNjRoA7oMbcO2xbGgF8eVS/LVFew5qYbe1iT0W6nbzbMwLcAdUz4KxuMxEgcR9dv/PM1ui6pJsG6b1V5s163VRIqURgMAQ6OsU42POw4ggCjF8RYHiZCBRDgMS9GJRFBHHGogiMUxEy3bd8TgVhtnMMCHT33sAxPB3bYBCY7ls+zYPwJxEYJwIk7iPqF731uf7LIkf0AGxKcwS6/pRJ8xaxBBEohgDVuxiUkxJkzmj9fv3HpJrPxhKBUSNA4j6K7uGZrVF0w3CN4JTkcNiz5q4Q4IJSV8hORK6eiuLp0ol0Gps5AQRI3IfvJJ7ZGr4PRtACbgIeQSewCcUQMG7tr7u/i4mmoOkgwFP40+krtnQyCJC4D9xVmq7tHv9Q87UzAzea1XeDgOE6sXfqdVM5pRKBYgiQrhWDcvqCeAp/+n3IJxgXAiTuQ/aH/or4T2fvh2wK6x4HAtw0NY5+YCvaI8ANEu2xW9OS+gXHDw+fckpiTfuZj9UTAiTuPQFtquGZLQMIfwKBsp8ygVgmiEDXCJgjifxMWNeAT0i+DnkPD59SNybUd2zq2BAgcR+gR3hmawDQp1YlXww6tR7b9PbqWdVvZt9xVnXTFcJ7fp7C91DhNSLQDAES92Z45ec2+5h5Zisf0nWVoD9lwvMP69rL6/FcWlf5NbH16NOOnkKff9ib/8hjXR3hTLFrjACJe6+dS5/VK9zTr4yfMpl+H67/E3B1aP37uOgTcvaqKJwUtnEIkLj31+V6lZAvte0P94nXZI6r8lMmE+/PdWu+PorKz8atW+929jzGrf25vOisKgomAuuGAIl7Hz3KM1t9oLzWdZAerXX3TvLhyL0m2W2jaTRP4Y+mK9iQiSFA4t55h+kzW3wTVudwr28Fep/Vq5N97g1d366ewJPpTVzfHn3Po6gT6LNRNlG/E/nVyf4o28hGEYFxIUDi3m1/8NsT3eK7YdKpThvW4SN9XH42bqQdM81mUZ2m2W9s9WAIkLh3CD3PbHUI7qaK5gLOpvb8WJ6bU6Rj6Yk1agcXcNaoM/konSNA4t4VxNyU3BWyGy+XnzLZeBUYBgBuSh4G982o1RyZ4Cn8zeh2PmUbBEjc26CWLkMHlMaHd4sgoF9S9NPZ+yIyKYQIxBDgZ+NiyPB6QQQ44VUQTIpaVwRI3Av3rF7y4+cDC4NLcf9FQB9X5adM/osNf5VEgC/eLokmZSUR4BbTJDy8SQRWJO4llUB/PpCfuiyJLGVFECCjigDDy8UQ4PiwGJQUVA8BnsKvhxNzbSgCJO7FOp5ntopBSUFNEOAehiZoMW8zBPSOLH42rhl2zJ2BAE/hZ4DHomuOAIl7gQ7mma0CIFJEBgLUwAzwWNRHgJ+N83Hh1b4QoAb2hTTrmRgCJO65HWaOovLTzbmAsnxbBLjm0xY5lrMIcL7TIsLfAyHANZ+BgGe140WAxD2rb7jDOAs+Fi6NAD9lUhrRTZTHHcab2OsjfmZ9yoIfjR5xR7FpPSFA4t4eaO1N+E6P9jiyZFEE9HuN+C36otBuhDDt1kiSNqLLp/CQnCObQi+xjT0hQOLeEmi9fse3aLcEkcW6QcBs3+KnTLqBeQ2l8i3aa9ip6/JIPIW/Lj3J58hFgMS9MYL8bmVjyFhgCARIwoZAfap1crA31Z7bpHbr4Lt1sD2//G2Tnp7PSgT+FwES92aqwEF/M7yYe1AE+CmTQeGfTOV6exU/GzeZbtvUhupT+Fzu3lQt2OjnJnFv0P08s9UALGYdBwL6o2DfHn3/z/2/42gXWzEWBLSG8LNxY+kVtiOJAE/hJ+HhzTVHgMS9bgfzzFZdpJhvZAjoV/txPnVknTNwc/Tk5auT/YFbw+qJQG0EzHHVr7c3tYsyIxGYNgIk7rX6T28X5ucDa0HGTGNCgJ8yGVNvjKIt/GjXKLqBjchAwBzM4EdUMrBk0SkhQOJe0VuG8fAFHRV48faIEeD4c8Sd02vTyHh6hZuVdYmAdmu/nP/aZVWUTQRGgQCJe6obeGYrhQ7vTRAB7viaYKcVbjL3GBQGlOKGRoCn8IfuAdbfKwIk7lG49ZktnuqLwsQbU0PA8La/7v6e2hOwve0R0Kf6+Nm49jiy5MgQYLweWYewOR0iQOLug8sRvI8Lr64FAnyr6Vp0Y+OH4GfjGkPGAtNBgCvk0+krtjQLARJ3Cx/PbFlE+HsdEeCnTNaxV6PPxO6OQsMba4QAz6StUWfyUaIIkLj/Bxqe2foPHPyx7gjotwHyUybr2ttcYFnXnuVzuQjo46p8C5wLES9OGgES9//rPrP3l++F/T9omFpfBPSmZ35/Z/36mZ+NW78+5RNVIsBT+JUQMcN0ESBx/9++I32ZrhKz5ZkIcMiaCeBoi5O+jLZr2LCuEeCQtWuEKX8oBPog7lsH2/wbGwJDKdwm1/vn8mJsasD2tF5JJ3QjRGCT3ctQz663241QJTazSa3d2lBaxHobIUDivqGDikZawsxFECBxH2EQbR3hRvgsbFIRO6WQRgiQuI/Q7lq7tUZdz8xDIdAfcd85fv5m8a7d36PZztbB9qPZTrvilaXE8HJaWFlFqQyZUOwcP5eHHUrhNrleEPe9k9ct9GHv5LX0XbvidWqEetTJPHieTLOV4q0jXGbtbxbv8iWku6Br+enaG92lW5uuYwRxb9TjyEy3BijeLN7lo5Hp1qarhxvV8v6I+5vFu5vVst2f8Imd4+ftileWEl3PaWFlFaUyZEIBurBRWj6ShwVxny9PW+jDfHkqitqueJ0aoR51Mg+eJ9NsMyNcZu03q2W+hHQXdC0/XXuju3RrI/FRLZoB4t6ox5GZbg1Q3KyW+WhkurUWCsAi/SNA4v4/YwlGuP41bwNrJHHXISo/nWm2mREus/Ye3E5+C/P7qKYEEvfp+kMS95pKXicbift0DaHPlvdN3Bd3X94s3j2a7SzuvqT1eHb56fHR7uzy08X9VaZbT1fUQwStbED9DBqK2eWnnePns8tP6eIX91ePZjsvz/YFfAnnfSoZ6xIENHGfL0/3Tl7vnbxO993NainZ5svTfJ9eWddEZ9wXd19enu0/Ptq9uL9KP+Pb8w8wmYLEPacB3S30TZG4X9xfief/eP053ZWLuy+yeZJubVgHq4l7fbe2c/x87+Q13ZpRcu3k4VVMnvDny7P9Z/MXwgQy3dqwusTaayLQN3H/eP1ZFOvt+YdQ//SVZ/MXkpPEXcOiifuDwydbB9uPj3Z1hjA9u/wkSM4uP4GZ1dQPZiuIgCbu2MuYHsFe3F9J3z2bv9A+PezlIlegHkWkdS1EkHmzeKc1PF3p46PdrYPtB4dPMFzP3OMutDunASTuN6sl3JpW+HRXvj3/IArw8foz9LagtVJUTQQ0cddRO9F9i7sv0nfC3SXNHYBmq4zW8ASYN6sljojku7Wanc5swyLQN3G/WS3r0E24b5mShFtPq2/ru2AArSX0VlBDUZP8SREhK4xwA9qbJu41R7Dad5O4GyuD2V7cX4lXeTZ/YfLon6ALL8/28yMcar9ZLXMaQOKuifvNalmT/MkY7NFs52a1pFsb0K1p4l5zBIv+Or1d0K1pH6XRgL9KL8ye3i60L5J06/mIARWJVddHYADi/vJsX3QrMdeo+Ypx61rLS6W13peS2ZEcTdyNxbo1GuOHx6yvIsxZCgFN3DFNkl4w0TPE2qe7fZ1/EeqRL6oHCdps6wxi4XlObxdlibvsaKp0a24DSNyNh8eYNrEJEK5PxmDQ21KmSjn1EdDEHSPY9Jsk9Awx3Zp2lQYNGcQ+OHyS2ARoXJ94IRL3+go8xZwDEHfjc7XWIq35inHryFMwoRlAQbFdiNLEHeRPpp3c6jAEkoVIRrgBrdQQd0Pjwu4zgy7j08P8+VegHvmiepCgzRZsL7EHT9OF4sS9dQNI3EMPX7kqa2wHejugdW9s1Zq41xnBggCI5tOtaVdp0KizgmGMhcR9EyxxAOJeSTfBV2Q2JXTrWtGLpDUDKCKwOyGGuJsAFtZryAoj3IBWbYg7Ahj03HSf6Vzj003mIj+hHkWkdS3EmK0JYKZ2oAdmnxnhTO1wa7ElFDQATD2UYNqc+bNr+ZnN08WNWzOTiDqnpMWtAWro7YDWvbFVG+JeOYI1nQu74B53s8e9zh48oI3lqUy3trFqPK0HH4a4m2lg45cNXyFx1/iYCIdBjrsNLqSGjHAD2qch7jerpd6nq3tZsxMspzDCGYgMMQ39hs5v6ELxGfeb1bJdA8DjdWuLpA0+RWR2JMS4NTguFxyQFYzB6NYGdGuGuFeOYM0Am25N21SIRui4dP7wQAiJ+4C20FvVwxD3NN00k8Qk7tpQTYQD+ZOzpzqnyyQY4XozrbCikLhjBBu+/C7kLqFPN92d/xPqkS+qBwmGmAIxdwXD0IUuiHu7BrjctAh6Bp8iMjsSErq1MAqg6pDKQG9Do+OVrhEIiXtiBItBF2aI6dag2OGM+81qCcQwTEV+vMNDH8once9a4ccgfxjiDi4e0k2YsVbT0K1Dd4skJh3hEuQvJCuMcANaXUjcEyPYkJ3ANLimLFYfmm2M7blbRTMjXFg75hqxSALvlGgAiTvCgT7RCE8lJ4mBJI4/arKCzANa98ZWHRL3xAg2nCGmW4Nuu8QdXgUbw5AfXkXP+2S6tY1V42k9+GDEHTqHkbeoY8hXXLcO3S2ScGNwEcnFhYRjGHfYHRupM8INaJ8hccfL78L3BoSDLkY4Y02h2cYGsSFd6GLG/Wa1bNEAEnfXw8fGtG7goFsb0K2FxB3rwGYE64YqujXt1lw0YisY5h0eIofEfUBb6K3qwYi7a8N4y7ueenHdutb1/HTIABrJlC+AyIdg0gUXd1/kK0iSOfFCzJickLiD/G0dbOuXRrlDIEa43kwrrMgl7i4RwfKoHta6Pj2mJ+H1N4t3+AvvyhWoRyxD5fW35x+klsplAVjN2/MPLQwBzFsTX5ftxVxNZoRznUaLBuj2V8LbKIPbwkYSkFnety3fuQz/t+s+CI95eJeXuC/Ig96GRscrXSPgEnd3BAtfp2eIK93afHkKx1XpVbRSIQ31wJXMhI7jH68/67CbKdlFw13BcF0NvCJfB9m12g8rfzDirt8bBb2HYWu+EnPrmRaii+dEOCzdbh1sm/GGrmJx90U4t9SF/zvHz81asC4Vpl3iHuIWIytwYcOq3WbW7hJ36I9e+ndniF2fHmpI7ApUbutgO5YH6hHLkL6OFm4dbCf46NvzD7KeoJu0c/wcfiBdC+5KcVORGIhewXA5RH6Ec2uHs6rfANN+PF1+ItbCFpJlD5LuL53Of4S0WwPPi5EV6O1mOpZhn9ol7m5PuSMxOI0YKUfnpr1KQqshIZGn5q2L+yvMiMEEHhw+0Tt7a4pys8XQCF9jgIcy/EFaReI+rFF0XfuQxB3TilB6l68gFiZosWsD9S+KrrcLP2hzgrif3i5CpqLN3theouVuhMNKBbbBhVReZMLau1Ysyg8RcIm7HsHKzGVs0BXz6Qlt0begbx0R94v7K03vYtaEZV/dHkk/mu004u5SylQUar5LF7oj7k0bYNqvuywz7eLTQiYUMuyyUlW4bg31YkwbG4PRrYXeprcrLnHHOjBGsC6Vj+3q1lqKzh2cuF/cX4kzcQ3BfbGbfpA66ZiTDzU/dp5H2kbi3pv+D1LRkMTd0E246dAAXLcemsF8efps/gLs4dFsZ+/kdWwcr4u3Cz/h4Ds2tEhYu1QNwq1b5aZjUGAaQMifu6DMb4MPYmOoNEbczQgWzA8TjaIJMZ/u6kl4UQeb8K5cQYyMZYhdX9x9MUru8lE8gm6MToe2H6sRzNtUBDcibC9GF1C8dYSTZpva5dXLcqtmA0IJ+pEXd1/2Tl5rbB/Ndp7NXxjd0EWQjrUQGWomKnst/Qh1aom5NUyLyIhOcDA7p+nW4GEGScSIO/yYrJ/Dt5iIDO0y16E2KDg4cRct1f7KpM1OATxC/UQMDePHsHkmND1pUmu3NogKsdKmCAxM3DH9trj7Eo4poe4xt44MetrS2NLWwXYlG5AioQ1o+SZ9ervQ0VQkuMQdNiZ5ZHnh4v4KzyvXa066x6CAwcuOYZEZPjicYFNFYf58BGLE3YxgRa8SL1yKRTijouanqIT8N7fwE+qBK3USH68/hwtKrjVheLl1sP34aFcGmcYQ6m+YlmcJK0ItF/dXeKLQvqR46wgXq137ojoNCNsPzEF9pC7zP7RuFJREooUmZ/onMNw62H4029k5fm7+8vlKzK1hTDu7/ARHGr7uEy3MN1JKaIpAjLibTYCxGWJErphbQ+cOS9yhfmJWiOO6eeGQMm1Z4d0EGnoyDi4u9JbSvNZurWnvM/8gCAxM3GEML8/2Y3ylzlYZ6LGJbfiZiI6Ye0vngY2d3i5i1bnEXRu2ibWYT6rvkmIRDi+NejTbARMKp+XQmEG0bcMrTRB3jGDBVIyq1FlThoq6CdhCwa0yH68/i0Jq4ZJ2rUnzex2n9RhYX3cfBBdjFQHDt+cfYnQBVt86wsVqNy90qmyAC9TNagnfGGKLK2nGnGghMKyT0G4qXWMdaW6ehFsTnXl8tAsbCcdgdGsDutYYcdcjWJhkOOhKUFVRFXRu/ShpdAwSzPVGPyFk62DbPIW+FcbcRrUk0MAwfnb5CUYRCherb+3WBlQkVl0fgYGJu6abonDGJEQvE25dh8mtg+0Hh08ktOi5Lrme2D7bKMJpK5WJQyke2+Ouw56xai0qFr+NZSagQGATq3ZH/6ixvoowZykEEsQdLA3UNmQnCZ+ulUQ2V2DD2LP5C6HC0NKCxN2wds2/Y/os7ycxd7Wc8MH10+l0wmwFRoBpqhMhUrx1hEvUjiWUOg1w26ZJz9bBNk4BmS1JrrcEROkWIltlArq0dbAdzvBVFq+TIeHWMEsizXB3FdKtlfJRLeQkiDv4Ogwh1J9Kt4bOFeIukR06uXP8vHIwCQl1VDGWR/soM7mAfSwhp49Ji11PoIEVDIDpPnimW2uhACzSPwLDE3dMD4vCuWE74dZxCEaKG1WGsT2a7RjSrC2nUYSDFxArhaXFiDsqmi9PzeABVHvrYNu0HKVMIgGFdh8xD4LG969qrDFB3DGCFVV0B13QNBM2tIa4u1ZEu0Sy/NdFdBrqoS8m0rAvGTCjeKO5MQxaZCdGojpzK2G22rJidFOKd0Tc6zcgRtxfnu3vHD+XrSn6wUGGKh1OAh8tMJ3GmQGZ/pClgPny1HXUaVGJuwm3ptVDj2G0NCgenUz/CCSIu3Fr7qCr0q2hcyWo6dkB0fCtg+1n8xcmtrrqoS82TcPXbR1shx4YLXFX3evXlUYDg1ipzn1kudXarfWvP6yxBQLDE3dNN12+UrlVBjYTTiUu7r6EQ/zQikRCLIKa/OJHHs12xHphaZVx1MgxTq1OOyuh0E7Njaxwgi10hUUyEUgTdz2CdVURmhaGDVGt9MuLEmYCzYR64Eo6Ab4l2oviNYn77PLT3slrTCA9OHziKm2sDQmz1WzPpQudbpUxG13SDXD7OvbIZiExzRIS+MTkh9ehdTKswkyn/EzMhoSiElegSG4eXanrJ6F4mRbK4i0QSBN3PYLFwpHuZShYzK2hc7UHC9Ph3kLUAgm40iKhibuZZdOD2xiHqVljGg09aMerloxkQYbEvYUmT6jI8MQdX1lLBPuEW4eit+DN0PhGEe7j9Wdtt60boD1aOgCjnZXEHeQvxhXgwiako2vT1DRx1yNYl51A02IRTm/KenD4REhV+O6jcHwLBYN64Eo68fb8g24MiidsWQvUsfDx0W4j1g7mHSO+YHvaWnXtmRGu0mnUbECs/Wjq6e3i7fkH824ZqT3tNypbiCoSCd2nItD8TxCmhFhzK+Hhb1ZLuMrY86KRa+MrJvQgaeKuh9DuDHGlW0PniuI9OHwiPif0bDEHAglG6xr9hJCQaehbCe9ap7pKNDDN0ZFbm5DibXJTR0HcsQAU08WEW4eih+ZUx04kT06Ea9cAHDSRqmMeJ3yEBBR6u38smsLFbLLSD/XsaeIOJhpz/dA0zZWhIXrWZ+tg22iU5vQx+fq1ehDbKAHtqknc9QLRg8Mneyev3dAea0PabPHIsVlhKd56aipdu97Cl25AgrjPLj+B/Ut15n+MyApilS2MAauvA0ZTtf4Z89taTjqddmvwlnRrQ/muRL1p4g6/FJuKTrs17ZRE5RKeLXbkA34prYTpu3piRcjGx+vP8+Up2AssIi0nfbcSDfhMgwPESjNau7VER/PWeBAYBXHHIDK2+pNw61D0CRF3xCGxsUTkhjUikYDCHGhzORBc2HhUcHNakibuehnUZUJQdZe4464cmIbCSEILHw9xfzZ/8WbxTke+x0e7rt6ax5GfCfMBXUi8DTYzwiVq129zr2xAzPwxzSwVyf/HR7uaSfdA3EEURK9ml5/my1MzoghfXer2V+Ji2q3hkWMV0a0N6EXTxF0HO3cEC8flujVD3EOF156tcp05oYF1brkmqc1T0nVExfKk0dCDh9goRdpA4j6gRfRQ9fDEXRv21sG2G7YTbl2vxIVj+ov7q9jAVFuO6HosguqcYRqWVnPkYJ43NocUViRXElDg1Lk8jkv+GOF6MKpYFWniDnYiZ61CBYCmuREOPevOdmsiOx7ijmfEFq8EzUVmJBJmq60sxvYyI1yi9pvVsn4DXLejIzQOwcuDQw0qHU66hYAxnfh4/VkGV4YoGG/j6mRasr6bcGsGCpf8Qfljpsfr3SGQJu7Ss6KKbrCDPsdUCJ3b2rNBgla5FumL+yv9OPJQ8h+TjwnvWqfGNBp4kMQ5fmkPiXt3Cj8GycMTd81XYi8NSLh1vHlN9NVsDgYheHD4xA2QYktSNpEhYXKwtMo4aiYPGnEUNCABheYKscbA8segfJvWhgRxN8TaHcFC09wIh551w5veh5MILRACfWuUQPFYGxLSdORzR+9h2YTZ6nni2CubMiNconZ9bkeyuaPohAQ4rvD1UHqKMZyA1Cgl5OtsrdN6qaSd80TVCbemoYiNaaF4m+ZSxvC8CeJuBl0PDp+Epp12ayZoumomei7/oVE6AfXQF1un3yzeaWclr6kAoQ9nDxtVlEbDbJxzB7GCA4n7GEyjuzYMTNzBV57NX4gxuKtdCbdu9oeYaSGt6G7sFKPKiXCwtBhXht0aYu0esUfmWCIBhQyBHhw+wVjIDGO0E+xOpSg5hkCCuEM30HehekDT1pK4I/K5b1tzzSFmtqALANPdg5cZ4WK136yWjRrgchFQjXB4j4eqdDiJFrp4Nr2oG+k+RX2BCbcmYzDt1kLyh5bETI/Xu0MgQdwx6MIYL4zCabemY1ZsOkD0XP67Kgf1cO+2uyjfo8B6Pqh8eixdWVcCDWwugAdwVzAEBxL37hR+DJIHJu7gKx+vP8O2Q7qZcOs6TIrK7p28ni9PP15/hn6X/QCTsT1YWjqO4kmlkaH/MmJjP2NQgCvI40stIfmDCxuD8m1aGxLEHewEK0jhCBaa5hJ3xMiQ6oU2EtMuqEcsQ/o6irshVg5yybvJzQAbr0sSvXUfMKxaMoeUEc3QHzkO2Z4Ubx3hYrVrqlGnAWH7zU4bAVN2luvhTdrhYI3FlR+C6V6ZL0+fzV9IpSGAestvTi3o/ZD0gKy8PNuHCw2dJ3p801zKGJ43Qdxl4uzRbEfP0BlNS7s1bU3uegsk4zsDRr6WEN4qcgXBN1wfayo/gYYmSGKS7ibATLc2Bo1iGyoRGJi4a76ifbRR9xhbRTb4dNHa8L+7qITiiRiMPLEELC0RR/FoUlHIp2PCw+sxKMDb5EnhMY0ERrhKk+guQ4y4w+/LDAr4kBnBQtNcXou77vZHYyBGK/AT6oErjRIo7hJ3vcfDLCjr6OtuE3KbETNbrfyoNDQ6Kd4F7FYNZQAADnRJREFUcW/UAJfyXtxfiRBppPmP6b3ErqcixB3ouR2qW+jqpNtr7sWYW4MtyNSmPHjI76F43RkvJccQiBF3RD0ZpWveqXUAjiumQujcSs8WKoZUBAm63qbpxd0XGcQ+mu0Y96W9a5ppVFaaQENvSUCN4SA2063FepnXR4XAkMTd8BV8kMhYRWI+RpvB7PKTjmcIdXihtc5s0pLZjaAmZ/gTlpYg7jrCyW77N4t35i/mtkyNsQgnQyBAZwIehMCFjUoLN6QxMeKOThEdMAEPfQdNi6mK1n/NU0MWCJkmgZaY6zV/orjL8ww7xzrvxf2VaK+YYbjUEKvdNVugB3PWAU+LkuLFiXvTBqCdum3yCSfdodJa8Waw7q2D7QRRcPExtaR/6hOo2pGaV2jD7aSlJe7G3JoeAuldkWZMC8XbEE8yqseMEXdoqXQWBoHaNd2slpVuDZ0b6rNxHUYy9A0ScKVdQhog/8GY9Wfv3CnwRnXF0DDowZeGmwClea3d2qhUi42JITAkcYc5YaNYeEWUPubWjUlc3F+9Pf8gw+Kd4+d7J69nl5/CFV5TKnNqCpYWI+4YHGuzD9Ox+G1a60IBroAdCBgU4YrIAcIxheD17hCIEXfDTmIjWGhajLijc0W7Xp7ty/4KTYvlllEq/IQEXGmUQHGXuOsv6UgzHs12do6fG3oae7qwJSLEGE44sWcIBORI8dYRzq3dJZfpBpj2o3nyTkk4tGfzF2/PP4g3W9x9wbC/U+KutxnI8z4+2g27DCRGN75R2nVrUHgQsvCK1ALF6854KTmGQIy4hwPm8EoL4i5bAWU3rPZs7slXox6NdDLMDN+ibUHS8h+KGpateQUabtwgqgafCa9IFdKS1m4t1su8PioEhiTuIV8B3cRsnOii69ZrWkKdbKLriQiaEAJLixF37Vy0kZt0zdpdKMAMMATCey3MHAAj3IDm5xL3cNB1s1pi45N239A0fVFrppl/0gpmlFCX0mmoh75YP43iMeKeaKG01owz01VLEWM4ITlwEcZwvXWEc2t3jyikG2Dan37kRndjLWwkpLLLjK9uJByZXbcGaqLn18OooUcXA1r3xlbtEnczQywd7capSremvYrxY6Lh8j8xeoQE6Fu7xOLui5ll0A0oYgguGu78uotwvlvbWDWe1oMPRtwRzEzcEss0dNN16+1szy2VE+FgaS5xh8lpC3fTBge3nbFdQ24wA/nTc3JwYdNS0/VorUvcXXbijmChaTHiLnO0YWyTrxpprYtpF9QjliF9HcVjxF1aqE+No1UPDp80na+SstpwYsHMNRApXpa4t2iAbn8a3qZ3Q3yaSpD8F/dXbpclerlpRa6HF5JkNi675A+Ktx6OYlpP4RJ3uDXMEMvuL9FJPT6vdGvoXNE3dwU7wdr1uK6pWob5P15/drm7fqKwVP0rLhp4ZPOY4SQFifu0bKd1awcj7jBsPZuiX6eg6abr1usbQ2XOnAinl62NXcnbPLConU4k2JhufwhFjCu45A9OsLXGsGBrBFzi7jpfjND0CNb16Vo3kJ5dfpINY8/mL6CTWv2Q0ySgHuZ6zZ/z5SlqSevz6e3i5dn+zvHznePnehNIzYokW2i24JeaLujIrVslxcsS91gDMIoOGzB+4i5on94u3ize6S4zrrtR35nMoVuLkRW4NU2VoLetbZMFWyMQEndMV4U7sMMhdKVbC72KxFxRxZdn+5V6CPUwWtfup9mR+2bxrrIB9Sty0RDr0LFABGIQqxuQ6dZaqwEL9onAYMQ9xldcmw/den1LqJMzZAB1Sg2SJ4QiNgS6WS1DGgEX1qeSsS5BICTusUGXHsGCebs+vawSQj3Kiu1ImjFb13VI1WB7ejk7M8KZ2mUxQS6GfCXRgKkQ9446UcSGbi30XWhAuCoLvaWr6R+BkLjHBl3uJkC6NSi2u+PfdR1SBNsW9CA20631rz+ssQUCwxB38BWQEq27ocsO3brOn58OY3C+zI4kGCjw2gezoCy1hw6UEa6FkZQqEhJ3DLrMDLHLAhnhjE0Zsw21XecP2V5mhDO1u2OtOg0gccf6EpwYxmB6oAUwsXyBVVm6tVI+qoWckLhLkApniPUHJdCzdGtQbJe4Q9v1Yh2KhCsYmW6thQKwSP8IDEPcQ2oORbxZLUNab9iqzlwkHcbgImK7EGKgSJOVkNYzwvVvY6jREHewk3CCVjTH0HpGOGNQxmxDaq7zh5aSGeFM7bHj4GhDrAEk7iFxB1kBNQeMekwL8ke3BifTf8IQ98QMsXSiofV0a1q3QzRCaq7zw1JA6zPdWv/6wxpbIDAAca/kK+GbGQxb1YpbJB3G4CJiuxBioEgPgcKX0zHCtTCSUkUMcQ+ZnFEYjGDl1Gbo003+/J9Qj3xRPUjQZltJF0K3kxnhdO3uVKJBINYAEveQuKfHYOEmQOhtKVOlnPoIGOIeUkljCMbv0a1pfAwa7mYYnT/0e5lurX6/M+eACAxA3GG37myKKCXmGuXUhWGrWnGLpE0MLiKzIyEaitBow0oN+WOEG9DYDHGXrnQXlNGP+iiI8enIUzAB9SgosztR2mzRcsw8hfWaUW5mhNO1x86/mja4DSBxN8Qdbk3v3DVIIojIZkv0/oDWvbFVG+KeniHWCyay0ki3pnXboOEeP9X5YTuII5lubWPVeFoPPgBxr5xN0e+Nkqim2arR2iI/TQwuIrMjIRoKzG0khkDmaz6McAPapybuYCdY7ncVRo9gjU9382dehHpkyumnuDbbSrqg9+DJCkZmhNO1GyuLPb4ZRRsJsVKtr3ctv3XDwoLarYGs6K9ShEVkTCvb4qG3A1r3xlatiXvlDLH0I9zaxf0V3ZrWbYOGnrjR2XTaDGIz3drGqvG0Hrxv4l6Tr5hAqN26VtlS6YlGuDpDIP25SnmhmzzstNR0PVqriTsGXYkZYj2Clc+gSt+li+QYBQhQjpDeysJsa9IFswdPihd5HWROAzjjjllDYeF1xmBmEyD0dj0cxbSeQhP3moMuPYI1VLUL7wH16EJ4WZkaDY1SohazBy/TrU1L9za2tX0T9/nyVAaR6dkULD0/mu1c3F+RuMNuNRRC3BMLylJKWMWDwyezy09wYRur8QM+uCbuEuEezXbQs7GE8BgS9xAfEPfZ5SfxKvp9xmF+sL3HR7v5XypB7fI+mdYNIHHXxP3i/koUvvJrXEJxHhw+kfd8S3cMaN0bW3VI3MW+XAPERbEXujUAIglN3OHWwneOmVKyglHErW2sGk/rwfsm7tBOo3nhz4v7K5B7zVbDnPlXdAzOl9apBAPF6e2i0qrlJVPSKhL3Ae1TE3fZ6wkNT+gMulj79ET+nFtQjxwhvZU1ZltnIeLi/grkXooXmXGXR27XABJ3TdwFSeh8WpcAOPR2QOve2Ko1cZdT2jCxRPehi+nWNEoGDc2CdDaTXtx9AeaZbm1j1XhaDz4McTdqV/nTsNXK/E0zGAbQtHif+TOhYIQb0D4NcW+qNsanNy1eJz/Uo07mwfNkmm1mhMusHVP+JO4hcW+qWtDbAa17Y6s2xL1p39GtacTy0ch0axurxtN6cBL3ZQ8RVFtmZprEfVoGpltL4p6p/KZ4JnXOjHCZtffgdvJbaADv7ifdmnYU00qTuBe0CxL3aSn/UK3tj7jvHD9/s3jX7g/HldoVrywlES6nhZVVlMqQCYUEyK2D7aEUbpPrBXHfO3ndQh/wKoZ2xevUCPWok3nwPJlmK8Uzt8rkOI3M9lfi37X8ygbUz0C3Nl3HCOJev7t1Trq1smhkurXp6uFGtbw/4i76xP8jQWCjtHwkDwviPhIdYDO2DrYziTsxHBUCI7H0jWoGiPuoNGHDG9ParW2U6k73YUnctzfTwqerstNtOYn7CG2tdYQb4bOwSdN1DtNtOYn7CO2utVubrh5uVMv7IO4bBSgflggQASJABIgAESACRIAIdIEAiXsXqFImESACRIAIEAEiQASIABEojACJe2FAKY4IEAEiQASIABEgAkSACHSBAIl7F6hSJhEgAkSACBABIkAEiAARKIwAiXthQCmOCBABIkAEiAARIAJEgAh0gQCJexeoUiYRIAJEgAgQASJABIgAESiMAIl7YUApjggQASJABIgAESACRIAIdIEAiXsXqFImESACRIAIEAEiQASIABEojACJe2FAKY4IEAEiQASIABEgAkSACHSBAIl7F6hSJhEgAkSACBABIkAEiAARKIwAiXthQCmOCBABIkAEiAARIAJEgAh0gQCJexeoUiYRIAJEgAgQASJABIgAESiMAIl7YUApjggQASJABIgAESACRIAIdIEAiXsXqFImESACRIAIEAEiQASIABEojACJe2FAKY4IEAEiQASIABEgAkSACHSBAIl7F6hSJhEgAkSACBABIkAEiAARKIwAiXthQCmOCBABIkAEiAARIAJEgAh0gQCJexeoUiYRIAJEgAgQASJABIgAESiMAIl7YUApjggQASJABIgAESACRIAIdIEAiXsXqFImESACRIAIEAEiQASIABEojACJe2FAKY4IEAEiQASIABEgAkSACHSBAIl7F6hSJhEgAkSACBABIkAEiAARKIwAiXthQCmOCBABIkAEiAARIAJEgAh0gQCJexeoUiYRIAJEgAgQASJABIgAESiMAIl7YUApjggQASJABIgAESACRIAIdIEAiXsXqFImESACRIAIEAEiQASIABEojACJe2FAKY4IEAEiQASIABEgAkSACHSBAIl7F6hSJhEgAkSACBABIkAEiAARKIwAiXthQCmOCBABIkAEiAARIAJEgAh0gQCJexeoUiYRIAJEgAgQASJABIgAESiMAIl7YUApjggQASJABIgAESACRIAIdIEAiXsXqFImESACRIAIEAEiQASIABEojACJe2FAKY4IEAEiQASIABEgAkSACHSBwP8DBKsPwty1bDQAAAAASUVORK5CYII=)

Source: https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/
"""

import heapq

class node:
    def __init__(self, freq, symbol, left=None, right=None):
        # frequency of symbol
        self.freq = freq

        # symbol name (character)
        self.symbol = symbol

        # node left of current node
        self.left = left

        # node right of current node
        self.right = right

        # tree direction (0/1)
        self.huff = ''

    def __lt__(self, nxt):
        return self.freq < nxt.freq


# utility function to print huffman
# codes for all symbols in the newly
# created Huffman tree
def printNodes(node, val=''):

    # huffman code for current node
    newVal = val + str(node.huff)

    # if node is not an edge node
    # then traverse inside it
    if(node.left):
        printNodes(node.left, newVal)
    if(node.right):
        printNodes(node.right, newVal)

        # if node is edge node then
        # display its huffman code
    if(not node.left and not node.right):
        print(f"{node.symbol} -> {newVal}")


# characters for huffman tree
chars = ['a', 'b', 'c', 'd', 'e', 'f']

# frequency of characters
freq = [5, 9, 12, 13, 16, 45]

# list containing unused nodes
nodes = []

# converting characters and frequencies
# into huffman tree nodes
for x in range(len(chars)):
    heapq.heappush(nodes, node(freq[x], chars[x]))

while len(nodes) > 1:

    # sort all the nodes in ascending order
    # based on their frequency
    left = heapq.heappop(nodes)
    right = heapq.heappop(nodes)

    # assign directional value to these nodes
    left.huff = 0
    right.huff = 1

    # combine the 2 smallest nodes to create
    # new node as their parent
    newNode = node(left.freq+right.freq, left.symbol+right.symbol, left, right)

    heapq.heappush(nodes, newNode)

# Huffman Tree is ready!
printNodes(nodes[0])

"""Job Sequencing with Deadlines: In the Job Sequencing with Deadlines Problem, each job has a deadline and a profit associated with it. The goal is to schedule the jobs in a way that maximizes the total profit, considering that each job must be completed within its deadline. It's solved using a greedy strategy by selecting jobs based on their profits and deadlines."""

def job_sequencing(deadlines, profits):
    n = len(deadlines)
    jobs = sorted(zip(profits, deadlines), reverse=True)
    max_deadline = max(deadlines)
    schedule = [0] * (max_deadline + 1)
    total_profit = 0
    for profit, deadline in jobs:
        for i in range(deadline, 0, -1):
            if schedule[i] == 0:
                schedule[i] = profit
                total_profit += profit
                break
    return total_profit

# Example usage:
deadlines = [2, 1, 2, 1, 3]
profits = [100, 19, 27, 25, 15]
print(job_sequencing(deadlines, profits))  # Output: 142

"""Prim's Algorithm: Prim's Algorithm is used to find the minimum spanning tree (MST) of a connected, undirected graph with weighted edges. It starts with an arbitrary vertex and grows the MST by iteratively adding the shortest edge that connects a vertex in the MST to a vertex outside the MST. It's implemented using a greedy strategy with a priority queue to efficiently select the next edge to add to the MST.

Source: https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/
"""

# A Python3 program for
# Prim's Minimum Spanning Tree (MST) algorithm.
# The program is for adjacency matrix
# representation of the graph

# Library for INT_MAX
import sys


class Graph():
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0 for column in range(vertices)]
                      for row in range(vertices)]

    # A utility function to print
    # the constructed MST stored in parent[]
    def printMST(self, parent):
        print("Edge \tWeight")
        for i in range(1, self.V):
            print(parent[i], "-", i, "\t", self.graph[i][parent[i]])

    # A utility function to find the vertex with
    # minimum distance value, from the set of vertices
    # not yet included in shortest path tree
    def minKey(self, key, mstSet):

        # Initialize min value
        min = sys.maxsize

        for v in range(self.V):
            if key[v] < min and mstSet[v] == False:
                min = key[v]
                min_index = v

        return min_index

    # Function to construct and print MST for a graph
    # represented using adjacency matrix representation
    def primMST(self):

        # Key values used to pick minimum weight edge in cut
        key = [sys.maxsize] * self.V
        parent = [None] * self.V  # Array to store constructed MST
        # Make key 0 so that this vertex is picked as first vertex
        key[0] = 0
        mstSet = [False] * self.V

        parent[0] = -1  # First node is always the root of

        for cout in range(self.V):

            # Pick the minimum distance vertex from
            # the set of vertices not yet processed.
            # u is always equal to src in first iteration
            u = self.minKey(key, mstSet)

            # Put the minimum distance vertex in
            # the shortest path tree
            mstSet[u] = True

            # Update dist value of the adjacent vertices
            # of the picked vertex only if the current
            # distance is greater than new distance and
            # the vertex in not in the shortest path tree
            for v in range(self.V):

                # graph[u][v] is non zero only for adjacent vertices of m
                # mstSet[v] is false for vertices not yet included in MST
                # Update the key only if graph[u][v] is smaller than key[v]
                if self.graph[u][v] > 0 and mstSet[v] == False \
                and key[v] > self.graph[u][v]:
                    key[v] = self.graph[u][v]
                    parent[v] = u

        self.printMST(parent)


# Driver's code
if __name__ == '__main__':
    g = Graph(5)
    g.graph = [[0, 2, 0, 6, 0],
               [2, 0, 3, 8, 5],
               [0, 3, 0, 0, 7],
               [6, 8, 0, 0, 9],
               [0, 5, 7, 9, 0]]

    g.primMST()


# Contributed by Divyanshu Mehta

"""#Divide and Conquer

Merge Sort: Merge Sort is a divide-and-conquer algorithm that recursively divides the input array into two halves, sorts each half separately, and then merges the sorted halves. It's efficient for sorting large datasets and has a time complexity of O(n log n).
"""

def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left_half = merge_sort(arr[:mid])
    right_half = merge_sort(arr[mid:])
    return merge(left_half, right_half)

def merge(left, right):
    result = []
    i, j = 0, 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result

# Example usage:
arr = [12, 11, 13, 5, 6, 7]
print(merge_sort(arr))  # Output: [5, 6, 7, 11, 12, 13]

"""Quick Sort: Quick Sort is another divide-and-conquer algorithm that partitions the input array around a pivot element, such that all elements less than the pivot are on its left and all elements greater than the pivot are on its right. It then recursively sorts the subarrays to the left and right of the pivot. Quick Sort is generally faster than Merge Sort for most datasets and has an average-case time complexity of O(n log n)."""

def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# Example usage:
arr = [12, 11, 13, 5, 6, 7]
print(quick_sort(arr))  # Output: [5, 6, 7, 11, 12, 13]

"""Strassen's Matrix Multiplication: Strassen's Matrix Multiplication is an algorithm for multiplying two matrices using a divide-and-conquer approach. It recursively divides the matrices into smaller submatrices, performs matrix additions and subtractions to calculate intermediate results, and then combines these results to obtain the final product. Strassen's algorithm reduces the number of scalar multiplications compared to the naive approach, resulting in improved asymptotic complexity."""

import numpy as np

def strassen(matrix1, matrix2):
    size = len(matrix1)

    # Base case: if the matrices are 1x1, perform simple multiplication
    if size == 1:
        return [[matrix1[0][0] * matrix2[0][0]]]

    # Split matrices into quarters
    mid = size // 2
    A11 = [row[:mid] for row in matrix1[:mid]]
    A12 = [row[mid:] for row in matrix1[:mid]]
    A21 = [row[:mid] for row in matrix1[mid:]]
    A22 = [row[mid:] for row in matrix1[mid:]]

    B11 = [row[:mid] for row in matrix2[:mid]]
    B12 = [row[mid:] for row in matrix2[:mid]]
    B21 = [row[:mid] for row in matrix2[mid:]]
    B22 = [row[mid:] for row in matrix2[mid:]]

    # Strassen's recursive calls
    P1 = strassen(A11, np.subtract(B12, B22))
    P2 = strassen(np.add(A11, A12), B22)
    P3 = strassen(np.add(A21, A22), B11)
    P4 = strassen(A22, np.subtract(B21, B11))
    P5 = strassen(np.add(A11, A22), np.add(B11, B22))
    P6 = strassen(np.subtract(A12, A22), np.add(B21, B22))
    P7 = strassen(np.subtract(A11, A21), np.add(B11, B12))

    # Compute resulting submatrices
    C11 = np.add(np.subtract(np.add(P5, P4), P2), P6)
    C12 = np.add(P1, P2)
    C21 = np.add(P3, P4)
    C22 = np.subtract(np.subtract(np.add(P1, P5), P3), P7)

    # Combine resulting submatrices into one
    result = [[0] * size for _ in range(size)]
    for i in range(mid):
        for j in range(mid):
            result[i][j] = C11[i][j]
            result[i][j + mid] = C12[i][j]
            result[i + mid][j] = C21[i][j]
            result[i + mid][j + mid] = C22[i][j]

    return result

# Example usage:
matrix1 = [[1, 2, 3, 4],
           [5, 6, 7, 8],
           [9, 10, 11, 12],
           [13, 14, 15, 16]]

matrix2 = [[17, 18, 19, 20],
           [21, 22, 23, 24],
           [25, 26, 27, 28],
           [29, 30, 31, 32]]

print(np.array(strassen(matrix1, matrix2)))

"""Closest Pair of Points: The Closest Pair of Points problem involves finding the two points that are closest to each other among a set of points in a plane. It can be solved using various approaches, including a brute-force method that checks the distance between all pairs of points, and a divide-and-conquer method that exploits the spatial properties of the points to reduce the number of comparisons needed."""

import math

def euclidean_distance(p1, p2):
    """Calculate the Euclidean distance between two points."""
    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)

def brute_force_closest_pair(points):
    """Find the closest pair of points using brute force."""
    min_distance = float('inf')
    closest_pair = None
    n = len(points)
    for i in range(n):
        for j in range(i + 1, n):
            distance = euclidean_distance(points[i], points[j])
            if distance < min_distance:
                min_distance = distance
                closest_pair = (points[i], points[j])
    return min_distance, closest_pair

def strip_closest(strip, d):
    """Find the closest pair of points in the strip."""
    min_distance = d
    closest_pair = None
    strip.sort(key=lambda x: x[1])  # Sort strip by y-coordinate
    n = len(strip)
    for i in range(n):
        j = i + 1
        while j < n and (strip[j][1] - strip[i][1]) < min_distance:
            distance = euclidean_distance(strip[i], strip[j])
            if distance < min_distance:
                min_distance = distance
                closest_pair = (strip[i], strip[j])
            j += 1
    return min_distance, closest_pair

def closest_pair_divide_and_conquer(points):
    """Find the closest pair of points using the divide and conquer approach."""
    n = len(points)

    # Base case: if there are only two or three points, use brute force
    if n <= 3:
        return brute_force_closest_pair(points)

    # Sort points by x-coordinate
    points.sort()

    # Divide the points into two halves
    mid = n // 2
    left_half = points[:mid]
    right_half = points[mid:]

    # Recursively find the closest pairs in each half
    d_left, closest_pair_left = closest_pair_divide_and_conquer(left_half)
    d_right, closest_pair_right = closest_pair_divide_and_conquer(right_half)

    # Find the minimum distance between the two halves
    d = min(d_left, d_right)

    # Merge the two halves and find the closest pair in the strip
    strip = [point for point in points if abs(point[0] - points[mid][0]) < d]
    d_strip, closest_pair_strip = strip_closest(strip, d)

    # Return the closest pair among the three candidates
    if d_strip < d:
        return d_strip, closest_pair_strip
    elif d_left < d_right:
        return d_left, closest_pair_left
    else:
        return d_right, closest_pair_right

# Example usage:
points = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)]
closest_distance, closest_pair = closest_pair_divide_and_conquer(points)
print("Closest pair:", closest_pair)
print("Distance:", closest_distance)

"""Karatsuba Algorithm for Large Number Multiplication: The Karatsuba Algorithm is a fast multiplication algorithm for multiplying large numbers using a divide-and-conquer approach. It breaks down the multiplication of two n-digit numbers into three smaller multiplications of n/2-digit numbers, reducing the overall number of multiplications required. Karatsuba's algorithm has a better asymptotic complexity than the naive multiplication method for large numbers."""

def karatsuba(x, y):
    if x < 10 or y < 10:
        return x * y
    m = max(len(str(x)), len(str(y)))
    m2 = m // 2
    high1, low1 = divmod(x, 10 ** m2)
    high2, low2 = divmod(y, 10 ** m2)
    z0 = karatsuba(low1, low2)
    z1 = karatsuba((low1 + high1), (low2 + high2))
    z2 = karatsuba(high1, high2)
    return (z2 * 10 ** (2 * m2)) + ((z1 - z2 - z0) * 10 ** m2) + z0

# Example usage:
x = 1234
y = 5678
print(karatsuba(x, y))  # Output: 7006652
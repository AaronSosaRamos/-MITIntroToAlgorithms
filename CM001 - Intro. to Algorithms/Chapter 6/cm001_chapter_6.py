# -*- coding: utf-8 -*-
"""CM001 - Chapter 6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zF7wLBnqmJqoxwzAUk4yHHZOvVKO1v8b

# AVL Tree
"""

class AVLNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1


class AVLTree:
    def __init__(self):
        self.root = None

    def height(self, node):
        if not node:
            return 0
        return node.height

    def balance(self, node):
        if not node:
            return 0
        return self.height(node.left) - self.height(node.right)

    def right_rotate(self, y):
        x = y.left
        T2 = x.right

        x.right = y
        y.left = T2

        y.height = 1 + max(self.height(y.left), self.height(y.right))
        x.height = 1 + max(self.height(x.left), self.height(x.right))

        return x

    def left_rotate(self, x):
        y = x.right
        T2 = y.left

        y.left = x
        x.right = T2

        x.height = 1 + max(self.height(x.left), self.height(x.right))
        y.height = 1 + max(self.height(y.left), self.height(y.right))

        return y

    def insert(self, node, key):
        if not node:
            return AVLNode(key)

        if key < node.key:
            node.left = self.insert(node.left, key)
        else:
            node.right = self.insert(node.right, key)

        node.height = 1 + max(self.height(node.left), self.height(node.right))

        balance = self.balance(node)

        if balance > 1 and key < node.left.key:
            return self.right_rotate(node)

        if balance < -1 and key > node.right.key:
            return self.left_rotate(node)

        if balance > 1 and key > node.left.key:
            node.left = self.left_rotate(node.left)
            return self.right_rotate(node)

        if balance < -1 and key < node.right.key:
            node.right = self.right_rotate(node.right)
            return self.left_rotate(node)

        return node

    def insert_key(self, key):
        self.root = self.insert(self.root, key)

    def preorder_traversal(self, node):
        if node:
            print("{0} ".format(node.key), end="")
            self.preorder_traversal(node.left)
            self.preorder_traversal(node.right)

    def preorder(self):
        self.preorder_traversal(self.root)


avl_tree = AVLTree()
avl_tree.insert_key(10)
avl_tree.insert_key(20)
avl_tree.insert_key(30)
avl_tree.insert_key(40)
avl_tree.insert_key(50)
avl_tree.insert_key(25)

print("Preorder Traversal of constructed AVL tree is")
avl_tree.preorder()

"""# Min Heap Priority Queue"""

class MinHeapPriorityQueue:
    def __init__(self):
        self.heap = []

    def build(self, arr):
        n = len(arr)
        self.heap = arr
        for i in range(n // 2 - 1, -1, -1):
            self.heapify_down(i)

    def insert(self, x):
        self.heap.append(x)
        self.heapify_up(len(self.heap) - 1)

    def delete_min(self):
        if not self.heap:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()

        min_val = self.heap[0]
        self.heap[0] = self.heap.pop()
        self.heapify_down(0)
        return min_val

    def find_min(self):
        return self.heap[0] if self.heap else None

    def sort(self):
        sorted_arr = []
        while self.heap:
            sorted_arr.append(self.delete_min())
        return sorted_arr

    def heapify_up(self, index):
        parent = (index - 1) // 2
        while parent >= 0 and self.heap[parent] > self.heap[index]:
            self.heap[parent], self.heap[index] = self.heap[index], self.heap[parent]
            index = parent
            parent = (index - 1) // 2

    def heapify_down(self, index):
        n = len(self.heap)
        left_child = 2 * index + 1
        right_child = 2 * index + 2
        smallest = index

        if left_child < n and self.heap[left_child] < self.heap[smallest]:
            smallest = left_child

        if right_child < n and self.heap[right_child] < self.heap[smallest]:
            smallest = right_child

        if smallest != index:
            self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
            self.heapify_down(smallest)


pq = MinHeapPriorityQueue()
pq.build([4, 8, 2, 5, 1, 6, 9, 3])
print("Min Element:", pq.find_min())
print("Sorted Array:", pq.sort())

"""# Max Heap Priority Queue"""

class MaxHeapPriorityQueue:
    def __init__(self):
        self.heap = []

    def build(self, arr):
        n = len(arr)
        self.heap = arr
        for i in range(n // 2 - 1, -1, -1):
            self.heapify_down(i)

    def insert(self, x):
        self.heap.append(x)
        self.heapify_up(len(self.heap) - 1)

    def delete_max(self):
        if not self.heap:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()

        max_val = self.heap[0]
        self.heap[0] = self.heap.pop()
        self.heapify_down(0)
        return max_val

    def find_max(self):
        return self.heap[0] if self.heap else None

    def sort(self):
        sorted_arr = []
        while self.heap:
            sorted_arr.append(self.delete_max())
        return sorted_arr

    def heapify_up(self, index):
        parent = (index - 1) // 2
        while parent >= 0 and self.heap[parent] < self.heap[index]:
            self.heap[parent], self.heap[index] = self.heap[index], self.heap[parent]
            index = parent
            parent = (index - 1) // 2

    def heapify_down(self, index):
        n = len(self.heap)
        left_child = 2 * index + 1
        right_child = 2 * index + 2
        largest = index

        if left_child < n and self.heap[left_child] > self.heap[largest]:
            largest = left_child

        if right_child < n and self.heap[right_child] > self.heap[largest]:
            largest = right_child

        if largest != index:
            self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index]
            self.heapify_down(largest)


pq = MaxHeapPriorityQueue()
pq.build([4, 8, 2, 5, 1, 6, 9, 3])
print("Max Element:", pq.find_max())
print("Sorted Array:", pq.sort())

"""# Min Heap Binary Tree"""

class MinHeapBinaryTree:
    def __init__(self):
        self.heap = []

    def insert(self, value):
        self.heap.append(value)
        self.heapify_up(len(self.heap) - 1)

    def delete_min(self):
        if len(self.heap) == 0:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()

        min_val = self.heap[0]
        self.heap[0] = self.heap.pop()
        self.heapify_down(0)
        return min_val

    def heapify_up(self, index):
        while index > 0:
            parent_index = (index - 1) // 2
            if self.heap[parent_index] > self.heap[index]:
                self.heap[parent_index], self.heap[index] = self.heap[index], self.heap[parent_index]
                index = parent_index
            else:
                break

    def heapify_down(self, index):
        n = len(self.heap)
        left_child_index = 2 * index + 1
        right_child_index = 2 * index + 2

        smallest = index
        if left_child_index < n and self.heap[left_child_index] < self.heap[smallest]:
            smallest = left_child_index
        if right_child_index < n and self.heap[right_child_index] < self.heap[smallest]:
            smallest = right_child_index

        if smallest != index:
            self.heap[smallest], self.heap[index] = self.heap[index], self.heap[smallest]
            self.heapify_down(smallest)

    def display(self):
        print("Min Heap Binary Tree:")
        self._display(0, 0)

    def _display(self, index, level):
        if index < len(self.heap):
            self._display(2 * index + 2, level + 1)
            print("   " * level + str(self.heap[index]))
            self._display(2 * index + 1, level + 1)


min_heap_tree = MinHeapBinaryTree()
min_heap_tree.insert(10)
min_heap_tree.insert(20)
min_heap_tree.insert(15)
min_heap_tree.insert(30)
min_heap_tree.insert(40)
min_heap_tree.insert(25)

min_heap_tree.display()

print("Deleting min element:", min_heap_tree.delete_min())
min_heap_tree.display()

"""# Max Heap Binary Tree"""

class MaxHeapBinaryTree:
    def __init__(self):
        self.heap = []

    def insert(self, value):
        self.heap.append(value)
        self.heapify_up(len(self.heap) - 1)

    def delete_max(self):
        if len(self.heap) == 0:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()

        max_val = self.heap[0]
        self.heap[0] = self.heap.pop()
        self.heapify_down(0)
        return max_val

    def heapify_up(self, index):
        while index > 0:
            parent_index = (index - 1) // 2
            if self.heap[parent_index] < self.heap[index]:
                self.heap[parent_index], self.heap[index] = self.heap[index], self.heap[parent_index]
                index = parent_index
            else:
                break

    def heapify_down(self, index):
        n = len(self.heap)
        left_child_index = 2 * index + 1
        right_child_index = 2 * index + 2

        largest = index
        if left_child_index < n and self.heap[left_child_index] > self.heap[largest]:
            largest = left_child_index
        if right_child_index < n and self.heap[right_child_index] > self.heap[largest]:
            largest = right_child_index

        if largest != index:
            self.heap[largest], self.heap[index] = self.heap[index], self.heap[largest]
            self.heapify_down(largest)

    def display(self):
        print("Max Heap Binary Tree:")
        self._display(0, 0)

    def _display(self, index, level):
        if index < len(self.heap):
            self._display(2 * index + 2, level + 1)
            print("   " * level + str(self.heap[index]))
            self._display(2 * index + 1, level + 1)


max_heap_tree = MaxHeapBinaryTree()
max_heap_tree.insert(10)
max_heap_tree.insert(20)
max_heap_tree.insert(15)
max_heap_tree.insert(30)
max_heap_tree.insert(40)
max_heap_tree.insert(25)

max_heap_tree.display()

print("Deleting max element:", max_heap_tree.delete_max())
max_heap_tree.display()
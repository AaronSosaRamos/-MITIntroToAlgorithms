# -*- coding: utf-8 -*-
"""CM001 - Chapter 20.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bbUbCBSSfofgslqxaiV-cChDh7ajzR8I

#Acyclic Algorithms

Topological Sorting using Depth-First Search (DFS):
"""

def topological_sort(graph):
    visited = set()
    result = []

    def dfs(node):
        visited.add(node)
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                dfs(neighbor)
        result.append(node)

    for node in graph:
        if node not in visited:
            dfs(node)

    return result[::-1]  # Reversing the result to get the topological order

# Example usage:
graph = {
    'A': ['B', 'C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['F'],
    'E': [],
    'F': []
}
print(topological_sort(graph))

"""Shortest Path in a DAG:"""

from collections import deque

def shortest_path_dag(graph, source):
    topological_order = topological_sort(graph)
    distances = {node: float('inf') for node in graph}
    distances[source] = 0

    for node in topological_order:
        for neighbor, weight in graph.get(node, {}).items():
            distances[neighbor] = min(distances[neighbor], distances[node] + weight)

    return distances

# Example usage:
graph = {
    'A': {'B': 5, 'C': 3},
    'B': {'C': 2, 'D': 6},
    'C': {'E': 4},
    'D': {'F': 7},
    'E': {},
    'F': {}
}
print(shortest_path_dag(graph, 'A'))

"""#Hash Tables

Hash Function:
The hash function takes an input (often a key) and produces a fixed-size string or number, typically of a shorter length than the input. It's used to map keys to indices in the hash table.
"""

def hash_function(key, table_size):
    # Example hash function for string keys
    hash_value = 0
    for char in key:
        hash_value = (hash_value * 31 + ord(char)) % table_size
    return hash_value

"""Insertion into Hash Table:
To insert a key-value pair into a hash table, you first compute the hash value for the key, then store the value in the corresponding index of the table.
"""

def insert(hash_table, key, value):
    index = hash_function(key, len(hash_table))
    hash_table[index] = value

# Example usage:
hash_table = [None] * 10  # Initialize a hash table with 10 slots
insert(hash_table, "apple", 5)
insert(hash_table, "banana", 7)

"""Lookup in Hash Table:
To retrieve a value from the hash table, you compute the hash value for the key and look up the corresponding index in the table.
"""

def lookup(hash_table, key):
    index = hash_function(key, len(hash_table))
    return hash_table[index]

# Example usage:
print(lookup(hash_table, "apple"))  # Output: 5

"""Collision Handling (Chaining):
If two keys hash to the same index, a collision occurs. Chaining is a common technique to handle collisions by storing a linked list of key-value pairs at each index of the hash table.
"""

class HashTable:
    def __init__(self, size):
        self.size = size
        self.table = [[] for _ in range(size)]

    def insert(self, key, value):
        index = hash_function(key, self.size)
        self.table[index].append((key, value))

    def lookup(self, key):
        index = hash_function(key, self.size)
        for k, v in self.table[index]:
            if k == key:
                return v
        return None

# Example usage:
hash_table = HashTable(10)
hash_table.insert("apple", 5)
hash_table.insert("banana", 7)
print(hash_table.lookup("apple"))  # Output: 5
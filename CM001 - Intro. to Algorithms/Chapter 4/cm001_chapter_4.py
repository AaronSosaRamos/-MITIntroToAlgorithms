# -*- coding: utf-8 -*-
"""CM001 - Chapter 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K1brZrUTNXwRQBpuZhap-iOAf16b4N2c

# Hashing

Convert data to a fixed-size string of bytes (Generally, hexadecimal string)

Hash a String
"""

import hashlib

hash_object = hashlib.sha256() #256-bit hash value.

string_to_hash = "Hello, World!"
hash_object.update(string_to_hash.encode())

hashed_string = hash_object.hexdigest()

print("Hashed String:", hashed_string)

import hashlib

hash_object = hashlib.md5()  # Using the MD5 hashing algorithm

string_to_hash = "Hello, World!"
hash_object.update(string_to_hash.encode())

hashed_string = hash_object.hexdigest()

print("Hashed String (MD5):", hashed_string)

"""# Hashes of arrays (According to Jason Ku)


*   Faster search
*   Dynamic operations
*   Reduce time complexity




"""

class CustomKey:
    def __init__(self, value):
        self.value = value

    def __hash__(self):
        return hash(self.value)

    def __eq__(self, other):
        return self.value == other.value

custom_hash_table = {}
custom_key1 = CustomKey("key1")
custom_hash_table[custom_key1] = "value1"

custom_key2 = CustomKey("key1")
value = custom_hash_table[custom_key2]
print(value)

custom_key2 = CustomKey("key2")
custom_hash_table[custom_key2] = "value2"
value = custom_hash_table[custom_key2]
print(value)

custom_hash_table[CustomKey("key1")] = 'Hello World!'
print(custom_hash_table[CustomKey("key1")])

print(custom_hash_table)

"""Universal Hash Function (Use many hash functions from a family):"""

import random

class UniversalHashFunction:
    def __init__(self, num_buckets, p=10**9 + 7):
        self.num_buckets = num_buckets
        self.p = p
        self.a = random.randint(1, self.p - 1)
        self.b = random.randint(0, self.p - 1)

    def __call__(self, key):
        return ((self.a * hash(key) + self.b) % self.p) % self.num_buckets

class CustomHashTable:
    def __init__(self, num_buckets):
        self.num_buckets = num_buckets
        self.hash_function = UniversalHashFunction(num_buckets)
        self.buckets = [[] for _ in range(num_buckets)]

    def __setitem__(self, key, value):
        index = self.hash_function(key)
        for i, (k, v) in enumerate(self.buckets[index]):
            if k == key:
                self.buckets[index][i] = (key, value)
                return
        self.buckets[index].append((key, value))

    def __getitem__(self, key):
        index = self.hash_function(key)
        for k, v in self.buckets[index]:
            if k == key:
                return v
        raise KeyError(key)

custom_hash_table = CustomHashTable(10)
custom_hash_table["key1"] = "value1"
custom_hash_table["key2"] = "value2"
print(custom_hash_table["key1"])
print(custom_hash_table["key2"])

custom_key = CustomKey("example_key")
custom_hash_table[custom_key] = "value3"
print(custom_hash_table[custom_key])

print(custom_hash_table[CustomKey("example_key")])

custom_hash_table["key1"] = 'Hello World'
print(custom_hash_table["key1"])

print(custom_hash_table[CustomKey("example_key")])
custom_hash_table[CustomKey("example_key")] = 'Hello World 2'
print(custom_hash_table[CustomKey("example_key")])

"""Perfect Hashing (Without collisions):"""

class PerfectHashing:
    def __init__(self, keys):
        self.size = len(keys) ** 2
        self.table = [None] * self.size
        self.secondary_tables = [None] * self.size

        self.create_hash(keys)

    def primary_hash_function(self, key):
        return key % self.size

    def secondary_hash_function(self, key):
        return key ** 2 % self.size

    def create_hash(self, keys):
        for key in keys:
            index = self.primary_hash_function(key)
            if self.table[index] is None:
                self.table[index] = key
            else:
                if self.secondary_tables[index] is None:
                    self.secondary_tables[index] = [None] * (len(keys) ** 2)
                sec_index = self.secondary_hash_function(key)
                self.secondary_tables[index][sec_index] = key

    def search(self, key):
        index = self.primary_hash_function(key)
        if self.table[index] == key:
            return index
        elif self.secondary_tables[index] is not None:
            sec_index = self.secondary_hash_function(key)
            if self.secondary_tables[index][sec_index] == key:
                return index
        return -1

keys = [10, 22, 37, 41, 52, 60, 72, 89, 91]

perfect_hash = PerfectHashing(keys)

key_to_search = 60
index = perfect_hash.search(key_to_search)
if index != -1:
    print(f"Key {key_to_search} found at index {index}.")
else:
    print(f"Key {key_to_search} not found.")
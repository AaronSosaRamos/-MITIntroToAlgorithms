# -*- coding: utf-8 -*-
"""CM002 - Chapter 10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E__QxbkgBqv98pvqJh0ns3X4dM7o-6e7

#Augmentation

#Easy Tree Augmentation

To implement Easy Tree Augmentation as described, where each node stores a function of its subtree and updates can be performed in O(1) time per node, and modifications to a set of nodes cost O(# of ancestors of S) to update, we can create a generic tree data structure and then implement the augmentation functionality.
"""

class TreeNode:
    def __init__(self, value):
        self.value = value
        self.children = []
        self.subtree_function = None  # Function to store subtree information

class Tree:
    def __init__(self):
        self.root = None

    def add_node(self, parent_value, value):
        if not self.root:
            self.root = TreeNode(value)
            return

        parent_node = self.find_node(self.root, parent_value)
        if parent_node:
            new_node = TreeNode(value)
            parent_node.children.append(new_node)
        else:
            print("Parent not found. Node not added.")

    def find_node(self, node, value):
        if node.value == value:
            return node
        for child in node.children:
            found = self.find_node(child, value)
            if found:
                return found
        return None

    def update_subtree_functions(self, node):
        if not node:
            return 0

        total_children_function = 0
        for child in node.children:
            total_children_function += self.update_subtree_functions(child)

        # Update the node's subtree function based on children and its own value
        node.subtree_function = total_children_function + node.value

        return node.subtree_function

    def update_node_and_ancestors(self, node):
        while node:
            self.update_subtree_functions(node)
            node = self.find_parent(node)

    def find_parent(self, node):
        if node == self.root:
            return None
        else:
            return self._find_parent(self.root, node)

    def _find_parent(self, current, node):
        if node in current.children:
            return current
        else:
            for child in current.children:
                parent = self._find_parent(child, node)
                if parent:
                    return parent
            return None

# Example usage:
tree = Tree()
tree.add_node(None, 1)  # Root
tree.add_node(1, 2)
tree.add_node(1, 3)
tree.add_node(2, 4)
tree.add_node(2, 5)

# Update subtree functions
tree.update_subtree_functions(tree.root)

# Now each node should have its subtree function calculated
# Example: Print subtree function of each node
def print_subtree_functions(node):
    if not node:
        return
    print(f"Node {node.value}: Subtree function = {node.subtree_function}")
    for child in node.children:
        print_subtree_functions(child)

print_subtree_functions(tree.root)

"""#AVL Tree Augmentation

To implement the Easy Tree Augmentation in AVL Trees and 2-3 Trees, we need to modify the tree data structures and update functions to incorporate the augmentation functionality efficiently.
"""

class AVLNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1  # Height of the subtree rooted at this node
        self.subtree_function = None  # Function to store subtree information

class AVLTree:
    def __init__(self):
        self.root = None

    def height(self, node):
        if node is None:
            return 0
        return node.height

    def update_height(self, node):
        if node is None:
            return 0
        node.height = 1 + max(self.height(node.left), self.height(node.right))
        return node.height

    def balance_factor(self, node):
        if node is None:
            return 0
        return self.height(node.left) - self.height(node.right)

    def rotate_right(self, z):
        y = z.left
        T3 = y.right

        y.right = z
        z.left = T3

        self.update_height(z)
        self.update_height(y)

        return y

    def rotate_left(self, z):
        y = z.right
        T2 = y.left

        y.left = z
        z.right = T2

        self.update_height(z)
        self.update_height(y)

        return y

    def rebalance(self, node):
        if node is None:
            return None

        node.height = 1 + max(self.height(node.left), self.height(node.right))

        balance = self.balance_factor(node)

        # Left Heavy
        if balance > 1:
            if self.balance_factor(node.left) < 0:
                node.left = self.rotate_left(node.left)
            return self.rotate_right(node)

        # Right Heavy
        if balance < -1:
            if self.balance_factor(node.right) > 0:
                node.right = self.rotate_right(node.right)
            return self.rotate_left(node)

        return node

    def insert(self, node, key):
        if node is None:
            return AVLNode(key)
        elif key < node.key:
            node.left = self.insert(node.left, key)
        else:
            node.right = self.insert(node.right, key)

        return self.rebalance(node)

    def update_subtree_functions(self, node):
        if not node:
            return 0

        total_children_function = 0
        if node.left:
            total_children_function += self.update_subtree_functions(node.left)
        if node.right:
            total_children_function += self.update_subtree_functions(node.right)

        node.subtree_function = total_children_function + node.key

        return node.subtree_function

    def update_node_and_ancestors(self, node):
        while node:
            self.update_subtree_functions(node)
            node = self.find_parent(node)

    def find_parent(self, root, node):
        if root is None or root == node:
            return None

        if (root.left == node) or (root.right == node):
            return root

        if node.key < root.key:
            return self.find_parent(root.left, node)
        else:
            return self.find_parent(root.right, node)

# Example usage:
avl_tree = AVLTree()
avl_tree.root = avl_tree.insert(avl_tree.root, 10)
avl_tree.root = avl_tree.insert(avl_tree.root, 20)
avl_tree.root = avl_tree.insert(avl_tree.root, 30)
avl_tree.root = avl_tree.insert(avl_tree.root, 15)

# Update subtree functions
avl_tree.update_subtree_functions(avl_tree.root)

# Now each node should have its subtree function calculated
# Example: Print subtree function of each node
def print_subtree_functions_avl(node):
    if not node:
        return
    print(f"Node {node.key}: Subtree function = {node.subtree_function}")
    print_subtree_functions_avl(node.left)
    print_subtree_functions_avl(node.right)

print_subtree_functions_avl(avl_tree.root)

"""#2-3 Trees Augmentation:"""

class TwoThreeNode:
    def __init__(self, keys=None):
        self.keys = keys if keys else []
        self.children = []

    def add_key(self, key):
        self.keys.append(key)
        self.keys.sort()

class TwoThreeTree:
    def __init__(self):
        self.root = None

    def insert(self, key):
        if self.root is None:
            self.root = TwoThreeNode([key])
            return

        self._insert(self.root, key)

    def _insert(self, node, key):
        if len(node.children) == 0:
            node.add_key(key)
            if len(node.keys) == 3:
                self.split(node)
        else:
            child = self.get_child_for_key(node, key)
            self._insert(child, key)

    def get_child_for_key(self, node, key):
        for i, k in enumerate(node.keys):
            if key < k:
                return node.children[i]
        return node.children[-1]

    def split(self, node):
        left_child = TwoThreeNode([node.keys[0]])
        right_child = TwoThreeNode([node.keys[2]])

        if node.children:
            left_child.children = node.children[:1]
            right_child.children = node.children[1:]

        if node == self.root:
            self.root = TwoThreeNode([node.keys[1]])
            self.root.children = [left_child, right_child]
        else:
            parent = self.find_parent(self.root, node)
            parent.add_key(node.keys[1])
            parent.children.remove(node)
            parent.children.append(left_child)
            parent.children.append(right_child)

    def find_parent(self, root, node):
        if root.children and node in root.children:
            return root
        for child in root.children:
            parent = self.find_parent(child, node)
            if parent:
                return parent
        return None

    def update_subtree_functions(self, node):
        if not node:
            return 0

        total_children_function = sum(self.update_subtree_functions(child) for child in node.children)

        node.subtree_function = total_children_function + sum(node.keys)

        return node.subtree_function

    def update_node_and_ancestors(self, node):
        while node:
            self.update_subtree_functions(node)
            node = self.find_parent(self.root, node)

# Example usage:
two_three_tree = TwoThreeTree()
two_three_tree.insert(10)
two_three_tree.insert(20)
two_three_tree.insert(30)
two_three_tree.insert(15)

# Update subtree functions
two_three_tree.update_subtree_functions(two_three_tree.root)

# Now each node should have its subtree function calculated
# Example: Print subtree function of each node
def print_subtree_functions_23(node):
    if not node:
        return
    print(f"Node {node.keys}: Subtree function = {node.subtree_function}")
    for child in node.children:
        print_subtree_functions_23(child)

print_subtree_functions_23(two_three_tree.root)

"""#Order-Statistics Trees

Order-Statistics Trees are a type of binary search tree that augment each node to store the size of its subtree, allowing efficient computation of order statistics like rank and selection.

* insert(x): Inserts element x into the tree.
* delete(x): Deletes element x from the tree.
* successor(x): Finds the successor of element x.
* rank(x): Finds the rank of element x, i.e., the number of elements less than x.
* select(i): Finds the element with rank i.
"""

class OSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None
        self.size = 1

class OrderStatisticsTree:
    def __init__(self):
        self.root = None

    def _insert(self, node, key):
        if key < node.key:
            if node.left is None:
                node.left = OSTNode(key)
                node.left.parent = node
            else:
                self._insert(node.left, key)
        else:
            if node.right is None:
                node.right = OSTNode(key)
                node.right.parent = node
            else:
                self._insert(node.right, key)
        node.size += 1

    def insert(self, key):
        if self.root is None:
            self.root = OSTNode(key)
        else:
            self._insert(self.root, key)

    def _delete(self, node, key):
        if node is None:
            return node

        if key < node.key:
            node.left = self._delete(node.left, key)
        elif key > node.key:
            node.right = self._delete(node.right, key)
        else:
            if node.left is None:
                temp = node.right
                if temp:
                    temp.parent = node.parent
                del node
                return temp
            elif node.right is None:
                temp = node.left
                if temp:
                    temp.parent = node.parent
                del node
                return temp

            temp = self.minimum(node.right)
            node.key = temp.key
            node.right = self._delete(node.right, temp.key)
        node.size = self._size(node.left) + self._size(node.right) + 1
        return node

    def delete(self, key):
        self.root = self._delete(self.root, key)

    def minimum(self, node):
        while node.left:
            node = node.left
        return node

    def successor(self, key):
        node = self._search(self.root, key)
        if node is None:
            return None
        if node.right:
            return self.minimum(node.right).key
        parent = node.parent
        while parent and node == parent.right:
            node = parent
            parent = parent.parent
        if parent:
            return parent.key
        return None

    def _size(self, node):
        if node is None:
            return 0
        return node.size

    def _search(self, node, key):
        if node is None or node.key == key:
            return node
        if key < node.key:
            return self._search(node.left, key)
        return self._search(node.right, key)

    def rank(self, key):
        return self._rank(self.root, key)

    def _rank(self, node, key):
        if node is None:
            return 0
        if key == node.key:
            return self._size(node.left)
        if key < node.key:
            return self._rank(node.left, key)
        return self._size(node.left) + 1 + self._rank(node.right, key)

    def select(self, i):
        return self._select(self.root, i)

    def _select(self, node, i):
        if node is None:
            return None
        left_size = self._size(node.left)
        if i == left_size + 1:
            return node.key
        if i <= left_size:
            return self._select(node.left, i)
        return self._select(node.right, i - left_size - 1)

# Example usage:
ost = OrderStatisticsTree()
ost.insert(5)
ost.insert(3)
ost.insert(7)
ost.insert(2)
ost.insert(4)
ost.insert(6)
ost.insert(8)

print("Rank of 5:", ost.rank(5))  # Should print 4
print("Element with rank 3:", ost.select(3))  # Should print 4
print("Successor of 5:", ost.successor(5))  # Should print 6

ost.delete(5)

print("Rank of 7 after deleting 5:", ost.rank(7))  # Should print 3
print("Element with rank 1 after deleting 5:", ost.select(1))  # Should print 2
print("Successor of 4 after deleting 5:", ost.successor(4))  # Should print 6

"""#Finger Search Trees

Finger Search Trees are a type of binary search tree that allows for efficient searching by using "fingers", which are references to specific nodes in the tree. The fingers can be used to quickly traverse the tree from one node to another without traversing the entire tree.
"""

class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

class FingerSearchTree:
    def __init__(self):
        self.root = None
        self.finger = None  # Initialize finger to None initially

    def insert(self, key):
        if not self.root:
            self.root = Node(key)
            self.finger = self.root
        else:
            self._insert_recursive(key, self.root)

    def _insert_recursive(self, key, node):
        if key < node.key:
            if node.left is None:
                node.left = Node(key)
                return
            self._insert_recursive(key, node.left)
        elif key > node.key:
            if node.right is None:
                node.right = Node(key)
                return
            self._insert_recursive(key, node.right)
        else:
            # Key already exists
            return

    def delete(self, key):
        self.root = self._delete_recursive(key, self.root)

    def _delete_recursive(self, key, node):
        if node is None:
            return node

        if key < node.key:
            node.left = self._delete_recursive(key, node.left)
        elif key > node.key:
            node.right = self._delete_recursive(key, node.right)
        else:
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left

            # Node with two children: Get the inorder successor (smallest
            # in the right subtree)
            node.key = self._min_value_node(node.right).key

            # Delete the inorder successor
            node.right = self._delete_recursive(node.key, node.right)

        return node

    def _min_value_node(self, node):
        current = node
        while current.left is not None:
            current = current.left
        return current

    def search(self, key):
        return self._search_recursive(key, self.root)

    def _search_recursive(self, key, node):
        if node is None or node.key == key:
            return node
        if key < node.key:
            return self._search_recursive(key, node.left)
        return self._search_recursive(key, node.right)

    def update_finger(self, key):
        node = self.search(key)
        if node:
            self.finger = node

    def display(self):
        self._display_recursive(self.root)

    def _display_recursive(self, node):
        if node:
            self._display_recursive(node.left)
            print(node.key)
            self._display_recursive(node.right)

# Example usage
if __name__ == "__main__":
    # Create a FingerSearchTree object
    f_tree = FingerSearchTree()

    # Insert some elements
    f_tree.insert(10)
    f_tree.insert(5)
    f_tree.insert(15)
    f_tree.insert(7)
    f_tree.insert(12)

    # Display the tree
    print("Binary Search Tree:")
    f_tree.display()

    # Search for an element
    print("\nSearching for 7:", f_tree.search(7).key)

    # Update finger
    f_tree.update_finger(7)
    print("\nUpdated finger:", f_tree.finger.key)

    # Delete an element
    f_tree.delete(15)

    # Display the modified tree
    print("\nModified Binary Search Tree:")
    f_tree.display()
3

"""#Orthogonal Range Searching and Range Trees for 1-D, 2-D and d-D ranges

1-D Range
"""

class Node1D:
    def __init__(self, point):
        self.point = point
        self.left = None
        self.right = None

class RangeTree1D:
    def __init__(self):
        self.root = None

    def insert(self, point):
        if not self.root:
            self.root = Node1D(point)
        else:
            self._insert_recursive(point, self.root)

    def _insert_recursive(self, point, node):
        if point < node.point:
            if node.left is None:
                node.left = Node1D(point)
            else:
                self._insert_recursive(point, node.left)
        else:
            if node.right is None:
                node.right = Node1D(point)
            else:
                self._insert_recursive(point, node.right)

    def query_range(self, x_min, x_max):
        return self._query_range_recursive(x_min, x_max, self.root)

    def _query_range_recursive(self, x_min, x_max, node):
        if node is None:
            return []

        result = []
        if x_min <= node.point <= x_max:
            result.append(node.point)

        if node.point >= x_min:
            result += self._query_range_recursive(x_min, x_max, node.left)

        if node.point <= x_max:
            result += self._query_range_recursive(x_min, x_max, node.right)

        return result

# Example usage for 1-D Range Tree
if __name__ == "__main__":
    r_tree_1d = RangeTree1D()
    points = [3, 7, 1, 5, 9, 4, 2]

    for point in points:
        r_tree_1d.insert(point)

    print("Points in range [2, 5]:", r_tree_1d.query_range(2, 5))

"""2-D Range"""

class Node2D:
    def __init__(self, point):
        self.point = point
        self.left = None
        self.right = None

class RangeTree2D:
    def __init__(self):
        self.root = None

    def insert(self, point):
        if not self.root:
            self.root = Node2D(point)
        else:
            self._insert_recursive(point, self.root)

    def _insert_recursive(self, point, node):
        if point[0] < node.point[0]:
            if node.left is None:
                node.left = Node2D(point)
            else:
                self._insert_recursive(point, node.left)
        else:
            if node.right is None:
                node.right = Node2D(point)
            else:
                self._insert_recursive(point, node.right)

    def query_range(self, x_min, x_max, y_min, y_max):
        return self._query_range_recursive(x_min, x_max, y_min, y_max, self.root)

    def _query_range_recursive(self, x_min, x_max, y_min, y_max, node):
        if node is None:
            return []

        result = []
        if x_min <= node.point[0] <= x_max and y_min <= node.point[1] <= y_max:
            result.append(node.point)

        if node.point[0] >= x_min:
            result += self._query_range_recursive(x_min, x_max, y_min, y_max, node.left)

        if node.point[0] <= x_max:
            result += self._query_range_recursive(x_min, x_max, y_min, y_max, node.right)

        return result

# Example usage for 2-D Range Tree
if __name__ == "__main__":
    r_tree_2d = RangeTree2D()
    points_2d = [(3, 5), (7, 2), (1, 8), (5, 6), (9, 1), (4, 9), (2, 3)]

    for point in points_2d:
        r_tree_2d.insert(point)

    print("Points in range [2, 5] x [4, 7]:", r_tree_2d.query_range(2, 5, 4, 7))

# Assume we have a RangeTree2D object named r_tree_2d already constructed

def orthogonal_range_search(x_min, x_max, y_min, y_max):
    return r_tree_2d.query_range(x_min, x_max, y_min, y_max)

# Example usage for 2-D Orthogonal Range Searching
if __name__ == "__main__":
    points_2d = [(3, 5), (7, 2), (1, 8), (5, 6), (9, 1), (4, 9), (2, 3)]

    for point in points_2d:
        r_tree_2d.insert(point)

    x_min, x_max, y_min, y_max = 2, 7, 4, 8
    print("Points in range [{}, {}] x [{}, {}]:"
          .format(x_min, x_max, y_min, y_max),
          orthogonal_range_search(x_min, x_max, y_min, y_max))

"""d-D Range:"""

class NodeDD:
    def __init__(self, point):
        self.point = point
        self.left = None
        self.right = None

class RangeTreeDD:
    def __init__(self, dimension):
        self.dimension = dimension
        self.root = None

    def insert(self, point):
        if not self.root:
            self.root = NodeDD(point)
        else:
            self._insert_recursive(point, self.root)

    def _insert_recursive(self, point, node, depth=0):
        axis = depth % self.dimension
        if point[axis] < node.point[axis]:
            if node.left is None:
                node.left = NodeDD(point)
            else:
                self._insert_recursive(point, node.left, depth + 1)
        else:
            if node.right is None:
                node.right = NodeDD(point)
            else:
                self._insert_recursive(point, node.right, depth + 1)

    def query_range(self, ranges):
        return self._query_range_recursive(ranges, self.root)

    def _query_range_recursive(self, ranges, node, depth=0):
        if node is None:
            return []

        axis = depth % self.dimension
        result = []

        # Check if point falls within all ranges
        within_ranges = all(r[0] <= node.point[axis] <= r[1] for r in ranges)

        if within_ranges:
            result.append(node.point)

        # Recurse on left and right subtrees based on range overlap
        if node.point[axis] >= ranges[axis][0]:
            result += self._query_range_recursive(ranges, node.left, depth + 1)

        if node.point[axis] <= ranges[axis][1]:
            result += self._query_range_recursive(ranges, node.right, depth + 1)

        return result

# Example usage for d-D Range Tree
if __name__ == "__main__":
    dimension = 3
    r_tree_dd = RangeTreeDD(dimension)
    points_dd = [(3, 5, 1), (7, 2, 4), (1, 8, 2), (5, 6, 3), (9, 1, 5), (4, 9, 7), (2, 3, 6)]

    for point in points_dd:
        r_tree_dd.insert(point)

    # Define ranges for each dimension
    ranges = [(2, 7), (3, 8), (1, 6)]
    print("Points in range:", r_tree_dd.query_range(ranges))
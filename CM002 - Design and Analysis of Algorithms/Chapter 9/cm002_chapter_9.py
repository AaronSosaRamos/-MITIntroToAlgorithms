# -*- coding: utf-8 -*-
"""CM002 - Chapter 9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_NjwvNTLNaXp_xWuaA3svPn9XyKA0z-0

#Hashing

#Universal Hashing
"""

import random

class UniversalHashing:
    def __init__(self, num_buckets):
        self.num_buckets = num_buckets
        self.p = self._find_prime_larger_than(num_buckets)
        self.a = random.randint(1, self.p - 1)
        self.b = random.randint(0, self.p - 1)

    def _find_prime_larger_than(self, n):
        # Helper function to find a prime larger than n
        def is_prime(x):
            if x <= 1:
                return False
            elif x <= 3:
                return True
            elif x % 2 == 0 or x % 3 == 0:
                return False
            i = 5
            while i * i <= x:
                if x % i == 0 or x % (i + 2) == 0:
                    return False
                i += 6
            return True

        prime_candidate = n + 1
        while True:
            if is_prime(prime_candidate):
                return prime_candidate
            prime_candidate += 1

    def hash(self, key):
        return ((self.a * key + self.b) % self.p) % self.num_buckets

# Example usage:
num_buckets = 10
universal_hash = UniversalHashing(num_buckets)

# Create a dictionary using universal hashing
hash_table = [[] for _ in range(num_buckets)]

# Insert some key-value pairs
key_value_pairs = [(5, 'apple'), (10, 'banana'), (15, 'orange')]
for key, value in key_value_pairs:
    bucket_index = universal_hash.hash(key)
    hash_table[bucket_index].append((key, value))

# Retrieve a value
key_to_lookup = 10
bucket_index = universal_hash.hash(key_to_lookup)
for k, v in hash_table[bucket_index]:
    if k == key_to_lookup:
        print(f"The value associated with key {k} is {v}")
        break
else:
    print("Key not found")

# Print the hash table
print("Hash table contents:")
for i, bucket in enumerate(hash_table):
    print(f"Bucket {i}: {bucket}")

"""#Dot-product hash family:"""

import random

class DotProductHashing:
    def __init__(self, num_buckets, dimension):
        self.num_buckets = num_buckets
        self.dimension = dimension
        self.vector = [random.randint(1, 100) for _ in range(dimension)]

    def hash(self, key):
        key_vector = self._key_to_vector(key)
        dot_product = sum(x * y for x, y in zip(key_vector, self.vector))
        return dot_product % self.num_buckets

    def _key_to_vector(self, key):
        # Simple hash to vector conversion
        return [(ord(c) if isinstance(key, str) else key) % 100 for c in str(key)]

# Example usage:
num_buckets = 10
dimension = 5
dot_product_hash = DotProductHashing(num_buckets, dimension)

# Create a dictionary using dot-product hashing
hash_table = [[] for _ in range(num_buckets)]

# Insert some key-value pairs
key_value_pairs = [(5, 'apple'), (10, 'banana'), (15, 'orange')]
for key, value in key_value_pairs:
    bucket_index = dot_product_hash.hash(key)
    hash_table[bucket_index].append((key, value))

# Retrieve a value
key_to_lookup = 10
bucket_index = dot_product_hash.hash(key_to_lookup)
for k, v in hash_table[bucket_index]:
    if k == key_to_lookup:
        print(f"The value associated with key {k} is {v}")
        break
else:
    print("Key not found")

# Print the hash table
print("Hash table contents:")
for i, bucket in enumerate(hash_table):
    print(f"Bucket {i}: {bucket}")

"""#Perfect Hashing"""

class PerfectHashing:
    def __init__(self, keys):
        self.keys = keys
        self.size = len(keys)
        self.first_level_size = self.size * self.size
        self.first_level_table = [None] * self.first_level_size
        self.second_level_tables = [None] * self.first_level_size

        self._build_perfect_hashing()

    def _hash_function(self, key):
        # Simple hash function for demonstration purposes
        return hash(key) % self.first_level_size

    def _build_perfect_hashing(self):
        # Build first level hash table
        for key in self.keys:
            hash_value = self._hash_function(key)
            if self.first_level_table[hash_value] is None:
                self.first_level_table[hash_value] = [key]
            else:
                self.first_level_table[hash_value].append(key)

        # Build second level hash tables
        for i in range(self.first_level_size):
            if self.first_level_table[i] is not None:
                self.second_level_tables[i] = {}
                keys_in_bucket = self.first_level_table[i]
                for j, key in enumerate(keys_in_bucket):
                    self.second_level_tables[i][key] = j

    def hash(self, key):
        first_level_hash = self._hash_function(key)
        if self.first_level_table[first_level_hash] is None:
            return None  # Key not found
        else:
            second_level_hash = self.second_level_tables[first_level_hash][key]
            return first_level_hash * len(self.first_level_table[first_level_hash]) + second_level_hash

# Example usage:
keys = [5, 10, 15, 20, 25]
perfect_hashing = PerfectHashing(keys)

# Perform some hash lookups
key_to_lookup = 15
hash_value = perfect_hashing.hash(key_to_lookup)
if hash_value is not None:
    print(f"The hash value for key {key_to_lookup} is {hash_value}")
else:
    print("Key not found")